#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language russian
\inputencoding utf8
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\align center
Министерство образования и науки Российской федерации
\end_layout

\begin_layout Standard
\align center
Федеральное агентство по образованию
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Новосибирский государственный университет
\end_layout

\begin_layout Standard
\align center
Механико-математический факультет
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Кафедра программирования
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Выпускная квалификационная работа специалиста
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
КАЛУГИН Михаил Борисович
\end_layout

\begin_layout Standard
\align center

\series bold
Управляемый запросами статический анализ для языка Ruby
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align right
Научный руководитель: 
\end_layout

\begin_layout Standard
\align right
Кандидат физико-математических наук, старший научный сотрудник
\end_layout

\begin_layout Standard
\align right
И.Н.
 Скопин
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Новосибирск 2009
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

  
\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Введение 
\end_layout

\begin_layout Standard
Понимание кода больших программных систем является сложной задачей для человека.
 В особенности сложной эта задача является в случае с динамическими языками.
 Они намного больше способствуют написанию кода с ошибками, с ними ощутимо
 затруднено чтение незнакомого кода.
 Если для статически типизированных языков (например, Java) программа считается
 действительно большой начиная с примерно 1 миллиона строк, то для динамических
 (например, Ruby) программа в 100 тысяч строк уже является гигантской и
 невероятно сложной в поддержке.
 
\end_layout

\begin_layout Standard
Тем не менее динамические языки являются крайне популярными, а во многих
 областях являются стандартом де-факто (например, веб-приложения).
 Поэтому решение проблем вызванных динамичностью таких языков является крайне
 актуальным.
 Человечество постоянно развивает способы борьбы с ними: юнит-тестирование,
 подробное документирование, системы статического анализа кода, "умные"
 интегрированные среды разработки.
 Именно разработке системы статического анализа с её интеграцией в среду
 разработки и посвящена данная работа.
 Для языка Ruby (как, впрочем, и для Python, PHP, и др.) данная проблема
 до сих пор не является решенной с приемлемым качеством.
 
\end_layout

\begin_layout Standard
Одними из основных причин, затрудняющих анализ программ на Ruby, являются
 следующие особенности языка: 
\end_layout

\begin_layout Itemize
динамическая типизация 
\end_layout

\begin_layout Itemize
не самая простая система типов (так называемый duck typing) 
\end_layout

\begin_layout Itemize
метапрограммирование 
\end_layout

\begin_layout Itemize
поддержка возможностей функционального программирования 
\end_layout

\begin_layout Standard
Такая область применения как интегрированные среды разработки накладывает
 специфические ограничения на статический анализатор: быстрое время отклика
 на вопросы в условиях постоянно изменяющейся программы, большой размер
 самой программы.
 В то же время не предъявляется требований к тому, чтобы анализировалась
 вся программа целиком.
\end_layout

\begin_layout Standard
Практически идеальным подходом к анализу в условиях описанных требований
 является управляемый запросами анализ с отсечениями (DDP), описанный в
 работе Спуна[].
 Данный подход оперирует с понятием запроса и позволяет производить лишь
 те вычисления, которые непосредственно необходимы для ответа на поставленный
 вопрос.
 Это позволяет эффективно работать с программами любых размеров.
 Возможность отсечений позволяет гарантировать то, что пользователь не будет
 ждать результатов анализа часами.
 
\end_layout

\begin_layout Standard
Полезным свойством такого подхода является то, что явно хранятся зависимости
 между запросами.
 Поэтому становится возможным эффективно пересчитывать результаты анализа
 при изменениях в программе, не выбрасывая все полученные ранее результаты.
 
\end_layout

\begin_layout Standard
Данная работа состоит из двух частей: теоретической и практической.
 Теоретическая часть предлагает модифицированный алгоритм DDP, позволяющий
 работать с инкрементальными запросами.
 Также описывается разработанный автором основанный на DDP статический анализато
р, позволяющий вычислять типы в языке Ruby.
 Приводятся оценки точности и времени работы.
 
\end_layout

\begin_layout Standard
Практическая часть представляет собой две реализации описанных алгоритмов.
 Первая реализация является существенно упрощенной (не поддерживается инкремента
льное обновление результатов, некоторые возможности языка).
 Не смотря на кажущиеся недостатки, она интегрирована в среду разработки
 DLTK Ruby [2], вместе с которой успешно используется по всему миру.
 Вторая реализация соответсвует описанной в теоретической части, и подлежит
 интеграции в DLTK Ruby взамен первой.
 
\end_layout

\begin_layout Standard
Тестирование обеих реализаций показывает жизнеспособность предлагаемых алгоритмо
в и соответствие ожиданиям, а также теоретическим оценкам.
 
\end_layout

\begin_layout Section
Задача
\end_layout

\begin_layout Subsection
Язык Ruby
\end_layout

\begin_layout Standard
Ruby — это динамический, рефлективный объектно-ориентированный язык общего
 применения.
 Ruby был создан в 1993 году в Японии.
 Действительную популярность язык приобрел в начале 2000х, после появления
 Ruby on Rails — системы программирования, позволяющей быстро разрабатывать
 веб-приложения.
 С того момента язык является крайне популярным, а Ruby on Rails, наверное,
 входит в тройку самых популярных решений для веб-приложений вместе с J2EE
 и PHP.
 Такая популярность и область применения открывают огромный спрос на “умные”
 развитые среды разработки, позволившие бы схожую c Java простоту редактирования
 кода.
 
\end_layout

\begin_layout Standard
Ruby поддерживает несколько парадигм программирования: функциональное, объектно-
ориентированное, императивное и рефлективное.
 Также он имеет динамическую типизацию и автоматическое управление памятью.
 В настоящий момент спецификации Ruby не существует, и язык полностью определяет
ся существующей реализацией интерпретатора.
 
\end_layout

\begin_layout Standard
Поскольку читатель может быть не знаком с деталями языка, представим некоторые
 ключевые его возможности.
 В Ruby все является объектом, и каждый объект является экземпляром какого-то
 конкретного класса.
 Например, литерал 42 является экземпляром класса Fixnum, true является
 экземпляром TrueClass, а nil это экземпляр NilClass.
 Как и в Java, корнем иерархии классов является Object.
 Классы являются экземплярами класса Class.
\end_layout

\begin_layout Standard
Есть несколько видов переменных, различаемых по префиксу: 
\end_layout

\begin_layout Itemize
локальные переменные не имеют префикса (x, y, z,...) 
\end_layout

\begin_layout Itemize
переменные экземпляра (поля) имеют префикс @ (@x, @y, @z, ...) 
\end_layout

\begin_layout Itemize
переменные класса (аналог статических переменных в Java) имеют префикс @@
 (@@x, @@y, ...) 
\end_layout

\begin_layout Itemize
глобальные переменные имеют префикс $ ($var)
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
floatname{algorithm}{Листинг}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Ruby,numbers=left,numberstyle={\small},stepnumber=1,tabsize=4"
inline false
status open

\begin_layout Plain Layout

a = 42 				# теперь a доступен
\end_layout

\begin_layout Plain Layout

b = a + 3 			# то же самое, что и b = a.+(3)
\end_layout

\begin_layout Plain Layout

c = d + 3 			# ошибка: d неопределен
\end_layout

\begin_layout Plain Layout

b = 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 			# b теперь экземпляр String
\end_layout

\begin_layout Plain Layout

b.length 			# вызов метода length без аргументов
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Container 		# по умолчанию наследник Object
\end_layout

\begin_layout Plain Layout

	def get()		# определение метода
\end_layout

\begin_layout Plain Layout

		@x		# чтения поля, метод возвращает это значение
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	def set(e)
\end_layout

\begin_layout Plain Layout

		@@last = @x	# запись в переменную класса
\end_layout

\begin_layout Plain Layout

		@x = e		# запись в поле
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	def Container.last() 	# метод класса
\end_layout

\begin_layout Plain Layout

		$gl = @@last
\end_layout

\begin_layout Plain Layout

		@@last
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

f = Container.new	# создание экземпляра
\end_layout

\begin_layout Plain Layout

f.set(3)	# можно было также написать f.set 3
\end_layout

\begin_layout Plain Layout

g = f.get	# g = 3
\end_layout

\begin_layout Plain Layout

f.set(4)
\end_layout

\begin_layout Plain Layout

h = Container.new.get	# возвращает nil
\end_layout

\begin_layout Plain Layout

l = Container.last	# возвращает 3
\end_layout

\begin_layout Plain Layout

$gl		# возвращает 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

i = [1, 2, 3]	# литерал массива
\end_layout

\begin_layout Plain Layout

j = i.collect { |x| x + 1 } 	# теперь j равен [2, 3, 4]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module MyEnumerable	# определение модуля
\end_layout

\begin_layout Plain Layout

	def leq(x)
\end_layout

\begin_layout Plain Layout

		(self.twc x) <= 0	# заметим, что метода 
\begin_inset Quotes eld
\end_inset

twc
\begin_inset Quotes erd
\end_inset

 здесь нет
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Container
\end_layout

\begin_layout Plain Layout

	include MyEnumerable	# 
\begin_inset Quotes eld
\end_inset

примешиваем
\begin_inset Quotes erd
\end_inset

 модуль
\end_layout

\begin_layout Plain Layout

	def twc(other)		# объявляем недостающий метод
\end_layout

\begin_layout Plain Layout

		@x.twc other.get
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f.twc f	# возвращает 0
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Пример программы на Ruby
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Листинг 1 демонстрирует образец кода на Ruby и иллюстрирует некоторые возможност
и языка.
 Локальные переменные не видны вне окружающей их определение области (scope).
 Локальная переменная начинает существовать в момент ее первого определения.
 Обращаться до определения к переменным нельзя.
 Поскольку Ruby динамически типизирован, в ходе работы программы переменная
 может принимать значения различных типов.
 
\end_layout

\begin_layout Standard
Строки 7-19 определяют новый класс Container с методами get и set, методом
 класса last , переменной экземпляра @x и переменной класса @@last.
 Возвращаемым значением метода является результат последней вычисленной
 команды (строка 9).
 Также возможны явные команды return.
 Экземпляры классов создаются с помощью метода new.
\end_layout

\begin_layout Standard
Синтаксис вызова методов стандартный (строка 21), хотя круглые скобки можно
 опускать (строки 20 и 22).
 Имена методов не обязаны быть буквенно-числовыми: возможен метод с именем,
 например “+”.
 В частности в строке 2 на самом деле вызывается метод (a.+(3)).
\end_layout

\begin_layout Standard
В отличие от локальных переменных, переменные экземпляров, классов и глобальные
 переменные инициализируются значением nil.
 Переменные класса являются общими для всех экземпляров класса.
 Говоря о правилах видимости, переменные классов и экземпляров доступны
 только внутри их класса.
 Глобальные переменные видны всюду.
 Также, всегда доступна переменная self, устанавливаемая интерпретатором
 в зависимости от контекста.
\end_layout

\begin_layout Standard
В языке есть константы.
 Константой является любая переменная, имя которой начинается с заглавной
 буквы.
 В частности, имена классов являются константами.
\end_layout

\begin_layout Standard
Как и большинство динамических языков, Ruby имеет специальный синтаксис
 для литералов массивов (строка 28) и хэш-таблиц.
\end_layout

\begin_layout Standard
Также Ruby поддерживает функции высшего порядка, называемые Ruby-блоками
 (или просто блоками, или замыканиями).
 Строка 29 показывает вызов метода collect, который создает новый массив
 применением переданного ему блока к каждому элементу исходного массива.
 Между вертикальными скобками указываются аргументы блока.
 Надо заметить, что в отличие от методов, блоки имеют доступ к локальным
 переменным окружающей их области.
 Любой метод в Ruby может принимать один блок в качестве последнего аргумента
 и вызывать его с помощью команды yield(v1,...vn).
 Блоки можно передавать и в качестве обычных аргументов, однако это не тривиальн
о и редко применяется.
 
\end_layout

\begin_layout Standard
Ruby поддерживает единственное наследование.
 Синтаксис class Foo < Bar означает, что класс Foo наследуется от класса
 Bar.
 Если суперкласс не указан, то он предполагается равным Object.
 
\end_layout

\begin_layout Standard
Аналогом множественного наследования в Ruby являются модули (modules, mixins).
 Например, строки 31-35 определяют модуль My_enumerable, который определяет
 метод leq в терминах другого метода twc.
 В строках 37-42 мы “примешиваем” модуль My_enumerable с помощью команды
 include и затем определяем необходимый метод twc.
 Начиная со строки 44 мы можем вызывать Container.leq.
 Заметим, что в строке 37 мы дополняем определение класса Container и примешивае
м модуль и добавляем метод.
 Это один из способов программно изменять классы.
 
\end_layout

\begin_layout Standard
Другими способом изменять классы являются методы alias и define_method.
 Вызывая alias у класса, мы можем создать копию какого-либо метода под другим
 именем.
 Вызов define_method принимает в качестве аргументов имя и блок, из которых
 под заданным именем создается метод.
 
\end_layout

\begin_layout Standard
Возможно создавать методы, специфичные для конкретного экземпляра (eigen
 methods или singleton methods).
 Синтаксис def obj.meth() ...
 end объявляет метод meth, который будет доступен только у экземпляра obj.
 Аналогичным по действию является синтаксис class << obj, позволяющий объявить
 несколько методов за раз и создающий область с переменной self равной obj.
 Возможность создавать методы специфичные для конкретных экземпляров означает,
 что тип в Ruby определяется не столько классом, сколько набором доступных
 у экземпляра методов.
 
\end_layout

\begin_layout Standard
Наконец, язык поддерживает возможность исполнения строк как кода на Ruby
 (eval, instance_eval, etc.).
\end_layout

\begin_layout Subsection
Специфика интегрированных сред разработки
\end_layout

\begin_layout Standard
Такая область применения статического анализа как интегрированные среды
 разработки имеет свою специфику, отличную от специфики применения статических
 анализаторов в трансляторах и верификаторах.
 Рассматривая самые востребованные действия пользователя, которые могут
 потребовать анализа программы, можно выделить следующие:
\end_layout

\begin_layout Enumerate
Подсказка при вводе метода (code completion).
 Реализация данной функции требует знать список имен методов, которые можно
 вызвать в указанной точке программы.
 А значит, это требует вычисления типа объекта, у которого вызывается метод.
 
\end_layout

\begin_layout Enumerate
Переход к определению (jump to declaration).
 Реализация перехода к определению требует зная имя метода, перейти к его
 определению.
 Для этого опять же нужно знать тип объекта, у которого вызывается метод.
 
\end_layout

\begin_layout Standard
Первой особенностью, которую можно заметить из данных кратких описаний,
 является формат обращения к анализу: в обоих случая это вопрос об одной
 единственной конкретной переменной (или выражении, что не важно).
 
\end_layout

\begin_layout Standard
Второй особенностью, и в частности требованием, является необходимость в
 малом времени на ответ на такие вопросы.
 Пользователь может ждать секунду-две, но не больше.
 При этом он не сильно огорчится, если результат окажется не полным или
 даже не корректным.
\end_layout

\begin_layout Standard
Третьей особенностью является то, что редактируя код, пользователь изменяет
 программу.
 А значит если статический анализатор сохраняет какие-либо результаты вычислений
 для оптимизации (а это логично делать), то после изменения программы, он
 должен эффективно их пересчитать.
 Можно привести простой практический пример: программа состоит из большой
 библиотеки и небольшого клиентского кода, ее использующего.
 Если пользователь работает над клиентским кодом, не изменяя код библиотеки,
 не эффективно анализировать ее заново при каждом запросе к анализу.
 Здесь нужно заметить, что длительный анализ в момент запуска среды разработки
 не возбраняется.
 Тем не менее при изменении кода, задержки на анализ должны быть пропорциональны
 масштабности изменений.
 
\end_layout

\begin_layout Standard
Наконец, нужно сказать про реализационные особенности.
 Так как среда разработки часто использует промежуточное представление и
 индексы, аналогичные тем, что могут понадобиться анализу, рациональным
 является совместное использование этих структур.
 А это означает, что анализ также должен быть реализован на языке, на котором
 возможна среда разработки.
 Рассматривая существующие среды, которые позволяют интеграцию в них анализа
 для Ruby, таким языком является Java.
 
\end_layout

\begin_layout Standard
Еще одним аспектом, ограничивающим выбор языка программирования для реализации,
 является скорость.
 К сожалению удобные для написания статического анализа языки, такие как
 Prolog, сам Ruby, Python, OCaml исполняются несравнимо более медленно чем
 Java.
\end_layout

\begin_layout Subsection
Существующие решения
\end_layout

\begin_layout Subsubsection
Специфичные для Ruby 
\end_layout

\begin_layout Paragraph
Static Type Inference for Ruby 
\end_layout

\begin_layout Standard
Авторами предлагается система под названием DRuby для поиска ошибок в программах
 на языке Ruby.
 Работа включает алгоритм для вычисления типов.
 Их алгоритм основывается на итеративном решении построенной системы ограничений
 и предлагается его реализация на OCaml.
 Авторы утверждают, что их алгоритм выдает точные ответы во всех возможных
 случаях.
 Однако время работы на тестовой программе в 800 строк составляет 36.1 секунды,
 что является слишком медленным, чтобы использовать их алгоритм в интерактивных
 средствах.
 Одним из результатов их работы являются типовые аннотации для стандартной
 библиотеки Ruby.
 Представленная здесь работа использует этот результат.
 
\end_layout

\begin_layout Paragraph
RadRails, RubyMine 
\end_layout

\begin_layout Standard
RadRails и RubyMine это популярные среды разработки для Ruby с поддержкой
 помощи пользователю (code completion).
 Документальных описаний статического анализа в них не известно.
 Однако экспериментальная проверка показала, что авторами скорее всего используе
тся тривиальный внутрипроцедурный анализ.
\end_layout

\begin_layout Subsubsection
Другие динамические языки 
\end_layout

\begin_layout Paragraph
DDP
\end_layout

\begin_layout Standard
Автором предлагается статический анализатор для языка Smalltalk основанный
 на управляемом запросами анализе с отсечениями.
 В его работе показывается применимость данного подхода к задачам статического
 анализа, а также выигрышность по сравнению с классическими (итеративными)
 подходами.
 Именно данная работа послужила источником идей для написания представленной,
 т.к.
 Smalltalk является во многом похожим на Ruby.
\end_layout

\begin_layout Subsection
Формальная постановка задачи
\end_layout

\begin_layout Standard
Задача состоит в разработке программной системы (статического анализатора),
 принимающего на вход обозначенные ниже данные и выдающие обозначенный ниже
 результат.
\end_layout

\begin_layout Standard

\series bold
Вход.
 
\end_layout

\begin_layout Standard
На вход анализатора поступает программа на Ruby: набор .rb файлов 
\begin_inset Formula $R$
\end_inset

, а также выбранный среди них файл 
\begin_inset Formula $m\in R$
\end_inset

, являющийся файлом, который непосредственно передается интерпретатору Ruby
 в качестве входного, и с которого начинается исполнение программы.
 Этот файл может включать остальные с помощью команды require.
 
\end_layout

\begin_layout Standard
Также анализатору указывается файл из входного набора и позиция в нем.
 На указанной позиции в этом файле должен находиться литерал, ссылающийся
 на какую-либо переменную.
 
\end_layout

\begin_layout Standard

\series bold
Выход.
 
\end_layout

\begin_layout Standard
На выход алгоритм должен выдать описание типа обозначенной на входе переменной.
 Описание типа должно следовать следующей структуре:
\end_layout

\begin_layout Standard
ОписаниеТипа := Тип (или Тип)* 
\end_layout

\begin_layout Standard
Тип := (Источник, Методы) 
\end_layout

\begin_layout Standard
Источник := <конкретное имя класса> 
\end_layout

\begin_layout Standard
Источник := <вызов метода new> 
\end_layout

\begin_layout Standard
Источник := <произвольный вызов с неизвестным возвращаемым типом> 
\end_layout

\begin_layout Standard
Источник := <неопределенная переменная> 
\end_layout

\begin_layout Standard
Методы := Метод* 
\end_layout

\begin_layout Standard
Метод := <описание сигнатуры метода: имя и аргументы> 
\end_layout

\begin_layout Standard
Описание типа должно соответствовать типам, которые может принимать указанная
 переменная в процессе работы программы.
 
\end_layout

\begin_layout Section
Решение
\end_layout

\begin_layout Subsection
Управляемый запросами анализ
\end_layout

\begin_layout Standard
Большинство из описанных ниже идей были заимствованы из работы Спуна[],
 которые им в свою очередь были заимствованы из экспертных систем.
 Таким образом общая идея управляемых запросами алгоритмов не нова.
 Данная работа расширяет существующие решение поддержкой кеширования результатов
 между запросами и эффективным обновлением закешированных данных при изменении
 анализируемой программы.
\end_layout

\begin_layout Subsubsection
Идея
\end_layout

\begin_layout Standard
Рассмотрим несколько наблюдений над существующими работами и над природой
 самой задачи.
 Данные наблюдения позволят лучше понять как решать поставленную задачу.
 
\end_layout

\begin_layout Standard
Во-первых, почти все современные контекстно-зависимые алгоритмы не масштабируемы.
\end_layout

\begin_layout Standard
Во-вторых, в любых программах, даже самых больших, большинство типов всегда
 вычисляется очень просто.
 Достаточно посмотреть на расположенные рядом присваивания, чтобы найти
 подходящий литерал.
 Любой человек таким образом взглянув на программу способен дать результат,
 порой более точный чем большинство из существующих анализаторов.
 
\end_layout

\begin_layout Standard
В-третьих, инкрементальный анализ традиционно считается крайне сложной задачей.
 В то же время, идея удаления ставших некорректными результатов, затем тех,
 которые зависят от них и т.д.
 выглядит тривиальной, если известны зависимости между результатами и результаты
 достаточно атомарны.
 
\end_layout

\begin_layout Standard
Наконец, рассмотрим такой пример ситуации.
 В любой достаточно большой программе всегда найдется метод, который вызывается
 из тысячи мест.
 Практически любой из существующих анализаторов потратил бы время на рассмотрени
е каждого из них.
 В то же время, для точного ответа на поставленный ему вопрос скорее всего
 достаточно рассмотрения лишь десятка из них.
 
\end_layout

\begin_layout Standard
Главной идеей является то, что статический анализатор мог бы, имея ограниченные
 ресурсы, потратить их лучшим образом на поиск ответа на заданный вопрос.
 Если ресурсов оказалось недостаточно, то он должен выдать тривиальный корректны
й ответ.
 При этом для разных типов вопросов он применял бы различные стратегии вычислени
я.
 Тогда на простые вопросы он мог бы отвечать быстро и хорошо, а на сложные
 хуже.
 
\end_layout

\begin_layout Standard
Управляемый запросами алгоритм следует описанной идее.
 На каждый поставленный ему вопрос выбирается своя стратегия вычисления.
 При этом в поисках ответа на вопрос он может задавать новые вопросы.
 
\end_layout

\begin_layout Standard
Естественным расширением этой идеи является то, что алгоритм мог бы не искать
 ответы на некоторые возникшие вопросы.
 В таком случае, если изначальный вопрос приводит к очень сложным вопросам,
 ответ на которые результат не улучшит, он мог бы не вычислять их.
 Это позволило бы успешно ответить на изначальный вопрос в условиях ограниченных
 ресурсов.
 Данное уточнение позволяет называть алгоритм управляемым запросами с отвечениям
и.
 
\end_layout

\begin_layout Standard
Важно заметить, что отсечения можно делать не с любыми вопросами.
 Вопросы должны быть правильно сформулированы.
 Например, вопрос “какой тип имеет x?” можно легко отсечь, потому что для
 него существует тривиальный корректный ответ: “Object”.
 Вопрос вида “проанализируй строку n и обнови таблицу b” отсекать невозможно,
 т.к.
 это вопросом в общем-то не является.
 Вообще, рассматривая данные примеры, становится ясным, что к вопросам предъявля
ются следующие требования: 
\end_layout

\begin_layout Itemize
существование тривиального корректного ответа
\end_layout

\begin_layout Itemize
отсутствие побочных эффектов от их рассмотрения (то есть каждый вопрос рассматри
вается изолированно)
\end_layout

\begin_layout Standard
Наконец, представим ситуацию, в которой алгоритму постоянно задают вопросы.
 Логично, что многие вопросы возникающие в процессе анализа будут повторяться.
 Поэтому естественным является записывать ответы на них, чтобы при повторных
 подобных вопросах не искать на них ответ.
 
\end_layout

\begin_layout Standard
Данная оптимизация, тем не менее, затрудняется если входные данные алгоритма
 меняются время от времени.
 Это означает, что старые ответы уже не корректны.
 Однако, бывает, решив какую-то задачу на бумаге, а потом получив аналогичную,
 вы переиспользуете большинство своих записей.
 Вы последовательно зачеркиваете устаревшие записи и записываете новые вместо
 них, затем те, на что те повлияли и т.д.
 Естественным решением проблемы, которое использует человек, является запоминани
е того, как вопросы зависят друг от друга и от входных данных.
 Подобную стратегию можно применять и при статическом анализе.
 
\end_layout

\begin_layout Subsubsection
Алгоритм
\end_layout

\begin_layout Standard
Предлагаемый алгоритм реализует идеи описанные выше.
 Он управляется запросами, позволяет делать отсечения и эффективно кеширует
 ответы между вопросами.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
floatname{algorithm}{Листинг}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

procedure Evaluate(rootgoal)
\end_layout

\begin_layout Plain Layout

	if completed contains rootgoal then
\end_layout

\begin_layout Plain Layout

		return GoalAnswer(rootgoal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	worklist := { rootgoal }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while worklist != {} do
\end_layout

\begin_layout Plain Layout

		if pruner wants to run
\end_layout

\begin_layout Plain Layout

		then Prune()
\end_layout

\begin_layout Plain Layout

		else UpdateOneGoal()
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return GoalAnswer(rootgoal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure UpdateOneGoal()
\end_layout

\begin_layout Plain Layout

	Remove g from worklist
\end_layout

\begin_layout Plain Layout

	changed := Update(g)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if changed then
\end_layout

\begin_layout Plain Layout

		deps := GoalsNeeding(g)
\end_layout

\begin_layout Plain Layout

		worklist := worklist + deps
\end_layout

\begin_layout Plain Layout

		completed := completed - deps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure Prune()
\end_layout

\begin_layout Plain Layout

	for g in ChoosePrunings() do
\end_layout

\begin_layout Plain Layout

		prune g
\end_layout

\begin_layout Plain Layout

	worklist := Relevant(rootgoal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procudure InputAffected(goal)
\end_layout

\begin_layout Plain Layout

	changed := Update(g)
\end_layout

\begin_layout Plain Layout

	if changed then
\end_layout

\begin_layout Plain Layout

		Wipe(goal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure Wipe(goal)
\end_layout

\begin_layout Plain Layout

	complete := completed - goal
\end_layout

\begin_layout Plain Layout

	deps := GoalsNeeding(goal)
\end_layout

\begin_layout Plain Layout

	for g in deps do 
\end_layout

\begin_layout Plain Layout

		Wipe(g)
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Управляемый запросами алгоритм с отсечениями и инкрементальным обновлением
 вычисленных запросов
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Псевдокод алгоритма представлен в листинге 2.
 На вход алгоритм принимает goal — исходный запрос.
 Выходом алгоритма является ответ на поставленный запрос.
 
\end_layout

\begin_layout Standard
Главной частью алгоритма является множество worklist содержащее набор запросов,
 ответы на которые нужно обновить.
 Алгоритм последовательно выбирает из worklist запросы и обновляет их ответы.
 Если после обновления ответа как какой-то запрос, ответ действительно изменился
, тогда все запросы зависящие от данного помещаются в worklist, так как
 теперь их ответ тоже мог измениться.
 Алгоритм останавливается, когда worklist окажется пустым, а значит ответы
 на все запросы будут согласованы с ответами на подзапросы.
 
\end_layout

\begin_layout Standard
Функция UpdateOneGoal обновляет ответ на переданный ей запрос так, чтобы
 он учитывал ответы на подзапросы.
 Например, для запроса “тип x?” ответ может уточниться с “Fixnum” до “Fixnum
 or Float”.
 Функция Update выполняет данное уточнение и возвращает булево значение,
 означающее изменился ответ по сравнению с предыдущим или нет.
\end_layout

\begin_layout Standard
Точное поведение Update зависит от конкретных типов вычислений, производимых
 с помощью данного алгоритма, и применительно к анализу Ruby рассматривается
 далее.
 Заметим, что если обновляемому запросу потребовались новые подзапросы,
 ранее не существовавшие, то тогда они создаются, инициализируются тривиальным
 ответом и добавляются в worklist.
 Если обновление ответа привело к тому, что ответ действительно изменился,
 то UpdateOneGoal помещает в worklist все запросы, запрашивавшие его как
 подзапрос.
\end_layout

\begin_layout Standard
Время от времени алгоритм вызывает Prune и отсекает некоторые подзапросы.
 ChoosePrunings выбирает какие запросы должны быть отсечены.
 ChoosePrunings это эвристика, и существует множество возможных стратегий
 по ее реализации.
 Всем запросам, которые отсекаются, назначается тривиальный ответ.
 После этого worklist очищается от отсеченных запросов, так чтобы он содержал
 только исходный запрос и все непосредственные и косвенные его подзапросы.
\end_layout

\begin_layout Standard
Для того чтобы GoalsNeeding не нарушала эффективности алгоритма, нужно чтобы
 после отсечений она не возвращала отсеченных запросов.
 Иначе это будет фактически отменять отсечения.
 Логично хранить дополнительный набор completed.
 Он должен хранить все запросы, которые обработаны и ответы на которые уже
 согласованы с подзапросами.
 Непосредственно после обновления запроса он должен помещаться в compeleted.
 И когда запрос помещается в worklist, он должен исключаться из completed.
 Таким образом во время работы алгоритма запросы перемещаются из completed
 в worklist и обратно, всегда находясь в одном из них.
 Отсеченные запросы удаляются из обоих наборов.
 GoalsNeeding же может возвращать только запросы, находящиеся каком-то из
 этих множеств.
\end_layout

\begin_layout Standard
Функция InputAffected вызывается между вызовами Evaluate, то есть предполагается
, что все обработанные ранее запросы находятся в completed.
 InputAffected перевычисляет потенциально изменившийся запрос, при условии
 что у него не было подзапросов (а значит он непосредственно зависел от
 входных данных и только).
 В случае, если его ответ действительно изменился, запрос, а также все прямо
 и косвенно зависящие от него удаляются из completed.
 Теперь при следующем обращении к Evaluate их потребуется вычислить заново.
\end_layout

\begin_layout Subsubsection
Пример работы
\end_layout

\begin_layout Standard
Проиллюстрируем работу алгоритма на конкретном примере.
 Рассмотрим случай анализа типов в программе, приведенной в Листинге 3.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
floatname{algorithm}{Листинг}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Ruby,numbers=left,numberstyle={\small}"
inline false
status open

\begin_layout Plain Layout

class MyClass
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def foo(p1) 		
\end_layout

\begin_layout Plain Layout

		$x = $y 		
\end_layout

\begin_layout Plain Layout

		doStuff() 		
\end_layout

\begin_layout Plain Layout

		$x = p1 		
\end_layout

\begin_layout Plain Layout

		$x 	
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	def baz 		
\end_layout

\begin_layout Plain Layout

		self.foo $y 	
\end_layout

\begin_layout Plain Layout

	end 
\end_layout

\begin_layout Plain Layout

	def boz 		
\end_layout

\begin_layout Plain Layout

		self.foo 45 	
\end_layout

\begin_layout Plain Layout

	end 
\end_layout

\begin_layout Plain Layout

	def qux 		
\end_layout

\begin_layout Plain Layout

		$y = 45 	
\end_layout

\begin_layout Plain Layout

	end 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Пример анализируемой программы.
 Нас интересует тип 
\begin_inset Formula $\$x$
\end_inset

 в строке 7.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
В данной программе нас интересует тип переменной $x в строке 7.
 Данный вопрос будет корневым запросом при запуске алгоритма.
 
\end_layout

\begin_layout Standard
Приведенные ниже схемы (рис.
 1 — рис.
 10) иллюстрируют работу алгоритма по шагам.
 На каждой схеме обозначены все существующие запросы.
 Запрос обозначается тремя строками:
\end_layout

\begin_layout Enumerate
Предмет запроса
\end_layout

\begin_layout Enumerate
Состояние: completed означает, что запрос находится в списке completed.
 Пустая строка означает, что запрос находится в списке worklist.
 
\end_layout

\begin_layout Enumerate
Ответ на запрос
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r1.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Начало работы над запросом 
\begin_inset Quotes eld
\end_inset

Что такое $x в строке 7?
\begin_inset Quotes erd
\end_inset

.
 Запрос находится в рабочем списке и имеет пустой ответ, обозначаемый как
 
\begin_inset Formula $\perp$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r2.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Корневой запрос обработан.
 Для него потребовалось два новых запроса, которые помещены в рабочий список.
 Ответ на корневой запрос согласован с ответами на подзапросы, и поэтому
 запрос перемещен в список completed.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r3.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Запрос 
\begin_inset Quotes eld
\end_inset

Что такое $y?
\begin_inset Quotes erd
\end_inset

 обработан и имеет непустой результат.
 Поскольку корневой запрос зависит от него, корневой запрос перемещен из
 completed в рабочий список.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r4.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Корневой запрос обработан второй раз.
 Теперь его ответ снова согласован с подзапросами и равен Fixnum.
 Корневой запрос снова перемещен в completed.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r5.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Обработан второй подзапрос корневого запроса.
 Для него потребовался ответ на запрос 
\begin_inset Quotes eld
\end_inset

Кто вызывает MyClass:foo
\begin_inset Quotes erd
\end_inset

, который помещен в рабочий список.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r6.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Обработан запрос 
\begin_inset Quotes eld
\end_inset

Кто вызывает MyClass:foo
\begin_inset Quotes erd
\end_inset

 и теперь он имеет ответ из двух точек вызова.
 От него зависит запрос 
\begin_inset Quotes eld
\end_inset

Что такое p1 в строке 6?
\begin_inset Quotes erd
\end_inset

, поэтому тот снова перемещается в рабочий список для обработки.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r7.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Повторное вычисление запроса 
\begin_inset Quotes eld
\end_inset

Что такое p1 в строке 6?
\begin_inset Quotes erd
\end_inset

 потребовало два подзапроса.
 Один из них уже вычислялся и имеет ответ Fixnum.
 Поэтому ответ на запрос изменился.
 От него зависит корневой запрос, поэтому тот помещается в рабочий список.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r8.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Корневой запрос снова согласован с подзапросами и помещен в completed.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r10.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Запрос 
\begin_inset Quotes eld
\end_inset

Что такое 45?
\begin_inset Quotes erd
\end_inset

 обработан.
 От него зависел 
\begin_inset Quotes eld
\end_inset

Что такое p1 в строке 6?
\begin_inset Quotes erd
\end_inset

, поэтому он помещен снова в рабочий список.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename run/r9.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Запрос 
\begin_inset Quotes eld
\end_inset

Что такое p1 в строке 6?
\begin_inset Quotes erd
\end_inset

 обработан снова.
 Его ответ не изменился.
 Рабочий список пустой, алгоритм останавливается.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Свойства
\end_layout

\begin_layout Standard
Приведенный алгоритм обладает несколькими полезными свойствами.
 Во-первых, время его работы зависит только от количества обрабатываемых
 запросов и того, сколько раз каждый из них обрабатывается.
 А значит, алгоритм должен работать одинаково быстро, если количество запросов
 ограниченно (это позволяют гарантировать отсечения).
 Предполагая, что с ростом размера программы, сложность взаимосвязей в ней
 растет слабо, ограничение числа запросов не должно вызывать значительных
 потерь в точности.
 То есть утверждается, что алгоритм сможет масштабироваться.
\end_layout

\begin_layout Standard
Затем, алгоритм в простых случаях находит ответ моментально.
 Так, вопросы приводящие через один-два шага к литералам, гарантированно
 будут найдены.
 
\end_layout

\begin_layout Standard
Наконец, алгоритм может быть настроенным под конкретную ситуацию.
 Выбирая стратегии отсечения можно контролировать соотношение скорости/качества.
 Также, обратим внимание на то, что не было указано, по какому принципу
 выбирается следующий запрос из worklist.
 Это также влияет на свойства алгоритма.
\end_layout

\begin_layout Standard
Если worklist работает по принципу очереди, то сначала будут рассматриваться
 более новые подзапросы.
 А значит алгоритм будет больше уходить “в глубину”, обновляя ответы на
 вопросы близкие к корневому в последнюю очередь.
 Если же worklist организовать по принципу стека, то появление конкретного
 ответа на какой-то подвопрос будет в первую очередь “просачиваться” наверх
 и уточнять корневой запрос до рассмотрения остальных подзапросов.
 Однако, ценой за такие скорые ответы является то, что корневой вопрос будет
 пересчитываться каждый раз, когда обновится какой-то из подзапросов, что
 может привести к общему замедлению работы.
\end_layout

\begin_layout Standard
Итак, стратегию выбора следующего запроса можно выбирать в зависимости от
 наличия ресурсов и конкретной задачи.
 При этом на результат данный выбор не влияет.
 Можно сформулировать следующее очевидное утвреждение:
\end_layout

\begin_layout Standard

\series bold
Утв.
 (корректность):
\series default
 Для любой стратегии выбора остановка алгоритма означает, что все ответы
 на все запросы согласованы с ответами на подзапросы.
 
\end_layout

\begin_layout Standard
Теперь давайте вернемся к словам про то, от чего зависит время работы алгоритма.
 Как было замечено, запросы могут обрабатываться несколько раз — фактически,
 каждый раз, когда изменятся ответ какого-то из их подзапроса.
 Возникает логичный вопрос о том, как часто один запрос может обновляться,
 и вообще останавливается ли алгоритм.
\end_layout

\begin_layout Standard
Во-первых, как уже было замечено, выбор стратегии может влиять на то, как
 часто запросы перевычисляются.
 Это является отдельным полем для исследования, и наверняка можно выбрать
 как стратегию с минимальным количеством пересчетов, так и с максимальным.
 Однако нам важен лишь тот факт, но данный выбор не влияет на результат.
\end_layout

\begin_layout Standard
Во-вторых, давайте представим запросы и зависимости между ними как орграф.
 Граф может быть двух видов: циклический и ациклический.
 Можно доказать следующее утверждение:
\end_layout

\begin_layout Standard

\series bold
Утв.
 (критерий остановки №1):
\series default
 Если запросы образуют ациклический граф, то для любых стратегий выбора
 и отсечения алгоритм останавливается.
 
\end_layout

\begin_layout Standard

\series bold
\begin_inset Formula $\blacktriangleleft$
\end_inset


\series default
 Индукция по размеру (количеству вершин) подграфа подзапроса.
 
\begin_inset Formula $\blacktriangleright$
\end_inset


\end_layout

\begin_layout Standard
Если граф циклический, алгоритм может не останавливаться.
 Но так как предусмотрены отсечения, то, выбрав подходящую стратегию отсечения
 можно алгоритм остановить.
 
\end_layout

\begin_layout Standard
Все же попробуем придумать условия, при которых можно гарантировать остановку
 без помощи отсечений.
 Для этого введем некоторый порядок на результатах запросов.
 Пусть все возможные результаты какого-либо запроса сравнимы, т.е.
 для любых двух ответов 
\begin_inset Formula $a_{1}$
\end_inset

 и 
\begin_inset Formula $a_{2}$
\end_inset

 можно было бы сказать 
\begin_inset Formula $a_{1}<a_{2}$
\end_inset

, 
\begin_inset Formula $a_{1}=a_{2}$
\end_inset

 или 
\begin_inset Formula $a_{1}>a_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
Опр.: 
\series default
Запрос будем называть монотонным, если при каждом последующем его обновлении
 предыдущий результат всегда больше (всегда меньше) предыдущего.
 
\end_layout

\begin_layout Standard
Тогда можно сформулировать следующее утверждение:
\end_layout

\begin_layout Standard

\series bold
Утв.
 (критерий остановки №2):
\series default
 Если все запросы монотонны и множество результатов каждого конечно, то
 алгоритм всегда останавливается.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\blacktriangleleft$
\end_inset

 Для любого запроса рано или поздно наступит момент, когда он больше не
 будет изменять свой ответ ввилу конечности цепи результатов, оставаясь
 согласованным со своими подзапросами.
 А значит также рано или поздно все запросы окажутся согласованными и алгоритм
 остановится.
 
\begin_inset Formula $\blacktriangleright$
\end_inset


\end_layout

\begin_layout Subsection
Первоначальные преобразования
\end_layout

\begin_layout Standard
В одной из предыдущих частей мы описали поставленную задачу следующих образом:
 
\end_layout

\begin_layout Standard

\emph on
Вход.
 
\end_layout

\begin_layout Standard

\emph on
На вход анализатора поступает программа на Ruby: набор .rb файлов R, ...
 
\end_layout

\begin_layout Standard
Иными словами, на вход разрабатываемого статического анализатора поступает
 текст программы.
 Очевидно, что производить анализ оперируя с текстом невероятно сложно и
 глупо.
 
\end_layout

\begin_layout Standard
Поэтому до начала непосредственно анализа программа проделывает следующий
 путь:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ir.png
	lyxscale 80
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
Первым преобразованием является лексический и синтаксический анализ.
 Выходом этого преобразования является дерево абстрактного синтаксиса (ДАС
 или, как оно будет обозначаться далее, AST).
 
\end_layout

\begin_layout Standard
Теоретически, анализ программы уже можно проводить на данном представлении.
 Однако, это все еще не является удобным ввиду следующих причин: 
\end_layout

\begin_layout Itemize
AST содержит слишком много конструкций, многие из которых равнозначны при
 вычислении типов;
\end_layout

\begin_layout Itemize
AST не отражает аспектов касающихся потоков данных и потока исполнения программы.
\end_layout

\begin_layout Standard
Поэтому AST преобразуется в структуры данных, более удобные для анализа.
 Под внутренним представлением мы будем понимать именно эти структуры.
\end_layout

\begin_layout Subsection
Внутреннее представление
\end_layout

\begin_layout Standard
На основе AST каждого входного файла, статическим анализатором строится
 внутреннее представление.
 Структуры данных, образующие ВП, можно разделить на две группы:
\end_layout

\begin_layout Enumerate
Основные.
 Основным представлением программы являются управляющие графы (УГ) для всех
 ее блоков (к блоками здесь также относятся и тела методов, помимо просто
 блоков, ввиду их одинаковой семантики) и кода верхнего уровня всех файлов.
 
\end_layout

\begin_layout Enumerate
Вспомогательные.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Внутрипроцедурная информация об использованиях и определениях переменных
 (DU&UD chains).
\end_layout

\begin_layout Enumerate
Индексы.
 Индексы хранят глобальную информацию о местах определений и присваиваний
 переменным, а также местах вызова и определения методов.
\end_layout

\end_deeper
\begin_layout Standard
Рассмотрим каждую из структур более подробно.
\end_layout

\begin_layout Subsubsection
Управляющие графы
\end_layout

\begin_layout Standard
Управляющие графы строятся для следующих элементов программы:
\end_layout

\begin_layout Itemize
верхнеуровневый код файлов
\end_layout

\begin_layout Itemize
код методов
\end_layout

\begin_layout Itemize
код блоков (замыканий)
\end_layout

\begin_layout Standard
Если вернуться к представлению в виде AST, то будет видно, что структурно
 вторые и третьи графы могут быть вложены друг в друга, а также все они
 обязательно вложены в графы первого вида.
 Информация о том, где именно в файле находится определение метода или блока,
 является важной.
 Более конкретно, важно, имея, например, только УГ замыкания эффективно
 определять, в каком контексте оно было определено.
 Поэтому введем понятие 
\emph on
контекстного управляющего графа
\emph default
 (КУГ): пары вида 
\begin_inset Formula $(G,v)$
\end_inset

, где 
\begin_inset Formula $G$
\end_inset

 — собственно граф, а 
\begin_inset Formula $v$
\end_inset

 — вершина какого-то другого графа, имеющая параметром данный (вершины УГ
 будут определены ниже).
\end_layout

\begin_layout Standard
Для того, чтобы описать устройство УГ, нам нужно описать множество вершин
 
\begin_inset Formula $V$
\end_inset

 и множество ребер 
\begin_inset Formula $E$
\end_inset

 этих графов.
 
\end_layout

\begin_layout Standard
Вершинами УГ будут являться пары вида 
\begin_inset Formula $(c,G)$
\end_inset

, где 
\begin_inset Formula $c$
\end_inset

 — какая-то 
\emph on
инструкция
\emph default
 языка, а 
\begin_inset Formula $G$
\end_inset

 — КУГ, содержащий данную вершину.
 Заметим, что в нашем случае управляющие графы обходятся без базовых блоков,
 храня непосредственно инструкции.
 
\end_layout

\begin_layout Standard
Определим 
\emph on
инструкции
\emph default
 возможные в КУГ.
 Каждая инструкция может иметь некоторые параметры (например, КУГ определяемого
 метода).
 Эти параметры будем называть также и параметрами соответствующей вершины
 графа.
 
\end_layout

\begin_layout Standard
Параметрами могут являться:
\end_layout

\begin_layout Itemize
Переменная: 
\begin_inset Formula $x$
\end_inset

 (локальная), или 
\begin_inset Formula $@x$
\end_inset

 (поле), или 
\begin_inset Formula $@@x$
\end_inset

 (класса), или 
\begin_inset Formula $\$x$
\end_inset

 (глобальная), или 
\begin_inset Formula $X$
\end_inset

 (константа), или 
\begin_inset Formula $self$
\end_inset

;
\end_layout

\begin_layout Itemize
Литерал: целое число, строка, массив вида 
\begin_inset Formula $[v_{1},...,v_{n}]$
\end_inset

 (где 
\begin_inset Formula $v_{i}$
\end_inset

 — либо другой литерал, либо переменная), хэш-таблица вида 
\begin_inset Formula $\{k_{1}=>v_{1},...,k_{m}=>v_{m}\}$
\end_inset

 (где 
\begin_inset Formula $k_{i}$
\end_inset

, 
\begin_inset Formula $v_{i}$
\end_inset

— какие-либо литералы или переменные);
\end_layout

\begin_layout Itemize
Объявляемые параметры: 
\begin_inset Formula $a_{1},\ldots,a_{n},[o_{1},\ldots,o_{m},[r,[b]]]$
\end_inset

, где 
\begin_inset Formula $a_{i}$
\end_inset

, 
\begin_inset Formula $o_{j}$
\end_inset

, 
\begin_inset Formula $r$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 — какие-то имена, соответствующие обязательным агрументам, опциональным,
 массиву с остальными аргументами и блоковому аргументу.
 
\begin_inset Formula $o_{j}$
\end_inset

, 
\begin_inset Formula $r$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 могут отсутствовать в последовательности, заданной квадратными скобками;
\end_layout

\begin_layout Itemize
Замыкание (блок): 
\begin_inset Formula $(CFG,params)$
\end_inset

 — пара состоящая из КУГ и объявляемых параметров;
\end_layout

\begin_layout Itemize
Вызов
\end_layout

\begin_deeper
\begin_layout Itemize
вида 
\begin_inset Formula $var.methodName(v_{1},\ldots,v_{n},closure)$
\end_inset

, где 
\begin_inset Formula $var$
\end_inset

, 
\begin_inset Formula $v_{i}$
\end_inset

 — переменные, а 
\begin_inset Formula $closure$
\end_inset

 — замыкание или переменная (может отсутствовать);
\end_layout

\begin_layout Itemize
вида 
\begin_inset Formula $yield(v_{1},\ldots,v_{n})$
\end_inset

, где 
\begin_inset Formula $v_{i}$
\end_inset

 — переменные.
\end_layout

\end_deeper
\begin_layout Standard
Теперь мы можем, наконец, определить набор инструкций:
\end_layout

\begin_layout Itemize
Присваивание: 
\begin_inset Formula $var=rhs$
\end_inset

, где 
\begin_inset Formula $var$
\end_inset

 — переменная, 
\begin_inset Formula $rhs$
\end_inset

 — литерал, переменная или вызов;
\end_layout

\begin_layout Itemize
Проверка условия: 
\begin_inset Formula $if(var)$
\end_inset

, где 
\begin_inset Formula $var$
\end_inset

 — переменная;
\end_layout

\begin_layout Itemize
Определение обычного метода: 
\begin_inset Formula $InstDef(var,name,CFG,params)$
\end_inset

, где 
\begin_inset Formula $var$
\end_inset

 — переменная равная классу/модулю у которого определяется метод, 
\begin_inset Formula $name$
\end_inset

 — имя метода, 
\begin_inset Formula $params$
\end_inset

 — объявляемые аргументы, 
\begin_inset Formula $CFG$
\end_inset

 — КУГ с содержимым метода;
\end_layout

\begin_layout Itemize
Определение синглетон метода: 
\begin_inset Formula $SinglDef(var,name,CFG,params)$
\end_inset

, где 
\begin_inset Formula $var$
\end_inset

 — переменная, 
\begin_inset Formula $name$
\end_inset

 — имя метода, 
\begin_inset Formula $params$
\end_inset

 — объявляемые аргументы, 
\begin_inset Formula $CFG$
\end_inset

 — КУГ с содержимым метода;
\end_layout

\begin_layout Itemize
Возврат из метода: 
\begin_inset Formula $Return(var)$
\end_inset

, где 
\begin_inset Formula $var$
\end_inset

 — переменная;
\end_layout

\begin_layout Itemize
Примешивание модуля: 
\begin_inset Formula $Include(var,var_{m})$
\end_inset

, где 
\begin_inset Formula $var$
\end_inset

 — переменная равная классу, а 
\begin_inset Formula $var_{m}$
\end_inset

— переменная или литерал, означающие модуль.
\end_layout

\begin_layout Itemize
\begin_inset Formula $ $
\end_inset

Включение файла: 
\begin_inset Formula $Require(v)$
\end_inset

, где 
\begin_inset Formula $v$
\end_inset

 — переменная или литерал с именем включаемого файла.
\end_layout

\begin_layout Itemize
Управляющие инструкции: 
\begin_inset Formula $break$
\end_inset

, 
\begin_inset Formula $next$
\end_inset

, 
\begin_inset Formula $redo$
\end_inset

.
\end_layout

\begin_layout Itemize
Вспомогательные инструкции: ВХОД и ВЫХОД.
 В каждом графе существуют в единственном экземпляре и обозначают входную
 и выходую вершины соответственно.
\end_layout

\begin_layout Standard
Необходимо прокомментировать соответствие определенного набора с командами
 и конструкциями языка.
 Во-первых, среди приведенных инструкций отсутствуют инструкции определения
 класса или модуля.
 Это вызвано тем, что в языке Ruby определение класса или модуля фактически
 равно присваиванию константе с именем класса экземпляра класса 
\begin_inset Formula $Class$
\end_inset

 или 
\begin_inset Formula $Module$
\end_inset

 соответственно.
 Поэтому определение класса заменяется на присваивание константе, а команды
 находившиеся внутри определения, оказываются на уровень выше.
\end_layout

\begin_layout Standard
Во-вторых, нужно заметить, что среди инструкций нет вызовов.
 Вызовы, стоящие в исходной программе 
\begin_inset Quotes eld
\end_inset

просто так
\begin_inset Quotes erd
\end_inset

, преобразуются в присваивания новым вспомогательным переменным.
 Это сделано для удобства определения возвращаемых значений методов/замыканий,
 которые могут быть равны последней выполненной команде.
 
\end_layout

\begin_layout Standard
Затем, так как среди инструкций нет циклов, то циклы в программе преобразуются
 контур из условного оператора и тела цикла с выходящим ребром соответствующим
 
\begin_inset Formula $else$
\end_inset

.
\end_layout

\begin_layout Standard
Наконец, заметим, что практически все инструкции имеют параметрами либо
 переменные либо литералы.
 Таким образом, вложенные вызовы и сложные выражения будут развернуты в
 несколько последовательных инструкций с использованием новых вспомогательных
 переменных.
 
\end_layout

\begin_layout Standard
Про ребра УГ нужно сказать, что они соотвествуют естественному порядку исполнени
я и легко могут быть построены читателем.
 
\end_layout

\begin_layout Standard
Рис.
 11 демонстрирует пример управляющего графа для программы из листинга 4.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
floatname{algorithm}{Листинг}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'socket'
\end_layout

\begin_layout Plain Layout

module Boz 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

class Foo 	
\end_layout

\begin_layout Plain Layout

	def bar(x) 		
\end_layout

\begin_layout Plain Layout

		if isGood(x) 			
\end_layout

\begin_layout Plain Layout

			y = Foo.zzz(x)  		
\end_layout

\begin_layout Plain Layout

		else 			
\end_layout

\begin_layout Plain Layout

			puts "oops" 		
\end_layout

\begin_layout Plain Layout

		end 	
\end_layout

\begin_layout Plain Layout

	end 	
\end_layout

\begin_layout Plain Layout

	def self.zzz(x) 		
\end_layout

\begin_layout Plain Layout

		56 	
\end_layout

\begin_layout Plain Layout

	end 	
\end_layout

\begin_layout Plain Layout

	include Boz 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

$f = Foo.new
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename cfg-example.png
	lyxscale 50
	width 100col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
КУГ для программы из листинга 3
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Использования и определения переменных
\end_layout

\begin_layout Standard
Будем говорить, что инструкция 
\begin_inset Formula $v$
\end_inset

 
\emph on
использует 
\emph default
переменную 
\begin_inset Formula $var$
\end_inset

, если выполнено хотя бы одно из условий:
\end_layout

\begin_layout Itemize
\begin_inset Formula $v$
\end_inset

 содержит переменную 
\begin_inset Formula $var$
\end_inset

 как параметр;
\end_layout

\begin_layout Itemize
\begin_inset Formula $v$
\end_inset

 является вызывом, и КУГ передаваемого замыкания содержит инструкцию, использующ
ую 
\begin_inset Formula $var$
\end_inset

.
\end_layout

\begin_layout Standard
Будем говорить, что инструкция 
\begin_inset Formula $v$
\end_inset

 
\emph on
определяет 
\begin_inset Formula $ $
\end_inset


\emph default
переменную 
\begin_inset Formula $var$
\end_inset

, если инструкция является присваиванием этой переменной.
\end_layout

\begin_layout Standard
Таким образом, для каждой переменной 
\begin_inset Formula $var$
\end_inset

 можно обозначить множества 
\begin_inset Formula $Def(var)\subseteq V$
\end_inset

 и 
\begin_inset Formula $Use(var)\subseteq V$
\end_inset

 — множества инструкций определяющих и использующих переменную 
\begin_inset Formula $var$
\end_inset

.
\end_layout

\begin_layout Standard
Пусть 
\begin_inset Formula $d\in Def(var)$
\end_inset

.
 Тогда определим 
\emph on
множество использований
\emph default
 данного 
\emph on
определения
\emph default
 следующим образом:
\begin_inset Formula \[
Use_{d}=\{u\in Use(var)|\exists p,p\in Paths(d,u)\,и\, p\cap Def(var)=\{d\}\}\]

\end_inset

, где 
\begin_inset Formula $Paths(d,u)$
\end_inset

 — множество всех путей от 
\begin_inset Formula $d$
\end_inset

 до 
\begin_inset Formula $u$
\end_inset

 в УГ.
 
\end_layout

\begin_layout Standard
Пусть теперь 
\begin_inset Formula $u\in Use(var)$
\end_inset

.
 Определим 
\emph on
множество определений достигающих использование
\emph default
 
\begin_inset Formula $u$
\end_inset

 следующим образом:
\begin_inset Formula \[
Def_{u}(var)=\{d\in Def(var)|\exists p,p\in Paths(d,u)\,и\, p\cap Def(var)=\{d\}\}\]

\end_inset


\end_layout

\begin_layout Standard
Множества 
\begin_inset Formula $Def_{u}(var)$
\end_inset

 и 
\begin_inset Formula $Use_{d}$
\end_inset

 являются необходимыми и крайне часто используемыми при внутрипроцедурном
 анализе.
 Поэтому имеет смысл предпросчитывать их до начала работы анализа, сразу
 после построения УГ.
 Сделать это можно с помощью алгоритма, приведенного в листинге 4.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
floatname{algorithm}{Листинг}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

procedure UpdateReachingDefs(CFG G, Node v, Map<Var, Node> reachingDefs)
 
\end_layout

\begin_layout Plain Layout

	rd = ReachingDefs[v] + reachingDef
\end_layout

\begin_layout Plain Layout

	if visited[v] && rd == reachingDefs
\end_layout

\begin_layout Plain Layout

		return
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	visited[v] = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if v defines var then
\end_layout

\begin_layout Plain Layout

		reachingDefs[var] = v
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	for u in Succ(v) do
\end_layout

\begin_layout Plain Layout

		UpdateReachingDefs(G, u, reachingDefs)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure BuildDefUse(CFG G)
\end_layout

\begin_layout Plain Layout

	for v in V(G) do
\end_layout

\begin_layout Plain Layout

		rd = reachingDefs[v]
\end_layout

\begin_layout Plain Layout

		for var in VarsUsedBy(v)
\end_layout

\begin_layout Plain Layout

			if rd[var]
\end_layout

\begin_layout Plain Layout

				Use[rd[var]] += v
\end_layout

\begin_layout Plain Layout

				Def[v, var] += rd[var]
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Построение множеств 
\begin_inset Formula $Def_{u}$
\end_inset

 и 
\begin_inset Formula $Use_{d}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Данный алгоритм строит множества 
\begin_inset Formula $Def_{u}(var)$
\end_inset

 и 
\begin_inset Formula $Use_{d}$
\end_inset

.
 При этом время его работы можно оценить как 
\begin_inset Formula $O(|V|*A)$
\end_inset

, где 
\begin_inset Formula $A$
\end_inset

 — количество обратных двуг в УГ.
 
\end_layout

\begin_layout Subsubsection
Индексы
\end_layout

\begin_layout Standard
Для оптимизации поиска в процессе глобального анализа, имеет смысл хранить
 следующие структуры данных:
\end_layout

\begin_layout Itemize
Для каждого имени глобальной переменной, поля, переменной класса и константы
 — все присваивания в программе переменной с таким именем.
\end_layout

\begin_layout Itemize
Для каждого имени глобальной переменной, поля, переменной класса и константы
 — все инструкции в программе, использующие перменные с таким именем.
\end_layout

\begin_layout Itemize
Для каждого имени метода список инструкций в программе, которые вызывают
 метод с таким именем.
\end_layout

\begin_layout Itemize
Для каждого имени метода список инструкций в программе, определеляющих метод
 с таким именем.
 
\end_layout

\begin_layout Standard
Данные списки строятся интуитивно понятным образом.
 
\end_layout

\begin_layout Standard
// дописать про инкрементальное обновление
\end_layout

\begin_layout Subsection
Запросы
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsubsection
Запросы о значениях
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsubsection
Запросы об использованиях
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsubsection
Запросы о точках вызова
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsubsection
Запросы о вызываемом коде
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Section
Результаты и эксперименты
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Section
Заключение
\end_layout

\begin_layout Standard
В данной работе была описана система для статического анализа программ на
 языке Ruby подходящая для использования в интегрированных средах разработки
 и тем самым удовлетворяющая поставленной задаче.
\end_layout

\begin_layout Standard
Была произведена следующая работа:
\end_layout

\begin_layout Itemize
разработан, описан и реализован модифицированный алгоритм DDP с поддержкой
 кеширования между запросами и инкрементальным обновлением результатов;
\end_layout

\begin_layout Itemize
исследован и описан язык Ruby;
\end_layout

\begin_layout Itemize
в рамках проекта DLTK Eclipse Foundation был реализован упрощенный статический
 анализатор для языка Ruby, а также алгоритм DDP без поддержки инкрементальности
;
\end_layout

\begin_layout Itemize
разработан, описан и реализован основанный на модифицированном DDP статический
 анализ для языка Ruby, позволяющий вычислять типы.
\end_layout

\begin_layout Standard
Данная работа показывает актуальность применения алгоритмов основанных на
 запросах в статическом анализе.
 Данный подход позволяет успешно решать проблему масштабирования, остро
 стоящую для многих алгоритмов анализа, при этом не значительно теряя в
 точности.
 Важно заметить, что такой подход может быть применен не только к анализу
 программ на языке Ruby, но и к анализу любых программ вообще.
 Более того, такой подход может быть применен для решения задач не только
 анализа программ.
 Крайне интересны возможные применения управляемого запросами анализа к
 задачам биоинформатики, социологии, экономики.
 
\end_layout

\begin_layout Standard
Наконец, еще одним существенным преимуществом такого подхода является предраспол
оженность к распараллеливанию.
 Если вычисляемые наборы запросов независимы, их можно эффективно вычислять
 на различных ядрах процессора.
 Решение задачи распараллеливания является одним из следующих шагов данной
 работы.
\end_layout

\begin_layout Standard
Тестирование реализации анализа для языка Ruby показало приемлемый уровень
 точности анализа.
 Однако были выявлены не учтенные изначально особенности языка, требующие
 более подробного рассмотрения: коллекции, исключения.
 Также было обнаружено, что точность описания библиотек и нативных функций
 оказывает крайне существенное влияние на точность анализа.
 
\end_layout

\begin_layout Standard
Реализация в рамках проектах Eclipse DLTK является достаточно популярной
 и делающей работу проще для многих разрабочиков на Ruby [].
 Также эта реализация используется в среде разработки для Ruby On Rails
 3rd Rail от CodeGear (бывшая Borland).
\end_layout

\begin_layout Standard
Наконец, данная работа является примером возможности создания практически
 полезных статических анализаторов для динамически типизированных языков.
 В частности, она может быть полезна при создании анализаторов для других
 динамических языков, таких как Python или PHP.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
makeatletter 
\end_layout

\begin_layout Plain Layout


\backslash
bibliographystyle{unsrt} 
\end_layout

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
@biblabel}[1]{#1.}  
\end_layout

\begin_layout Plain Layout


\backslash
makeatother
\end_layout

\end_inset


\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "/Users/fourdman/Desktop/bibliography"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
