#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language russian
\inputencoding utf8
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing double
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\align center
Министерство образования и науки Российской федерации
\end_layout

\begin_layout Standard
\align center
Федеральное агенство по образованию
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Новосибирский государственный университет
\end_layout

\begin_layout Standard
\align center
Механико-математический факультет
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Кафедра программирования
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Выпускная квалификационная работа специалиста
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
КАЛУГИН Михаил Борисович
\end_layout

\begin_layout Standard
\align center

\series bold
Управляемый запросами статический анализ для языка Ruby
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align right
Научный руководитель: 
\end_layout

\begin_layout Standard
\align right
Кандидат физико-математических наук, старший научный сотрудник
\end_layout

\begin_layout Standard
\align right
И.Н.
 Скопин
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Новосибирск 2009
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

  
\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Введение 
\end_layout

\begin_layout Standard
Понимание кода больших программных систем является сложной задачей для человека.
 В особенности сложной эта задача является в случае с динамическими языками.
 Они намного больше способствуют написанию кода с ошибками, с ними ощутимо
 затруднено чтение незнакомого кода.
 Если для статически типизированных языков (например, Java) программа считается
 действительно большой начиная с примерно 1 миллиона строк, то для динамических
 (например, Ruby) программа в 100 тысяч строк уже является гигантской и
 невероятно сложной в поддержке.
 
\end_layout

\begin_layout Standard
Тем не менее динамические языки являются крайне популярными, а во многих
 областях являются стандартом де-факто (например, веб-приложения).
 Поэтому решение проблем вызванных динамичностью таких языков является крайне
 актуальным.
 Человечество постоянно развивает способы борьбы с ними: юнит-тестирование,
 подробное документирование, системы статического анализа кода, "умные"
 интегрированные среды разработки.
 Именно разработке системы статического анализа с её интеграцией в среду
 разработки и посвящена данная работа.
 Для языка Ruby (как, впрочем, и для Python, PHP, и др.) данная проблема
 до сих пор не является решенной с приемлимым качеством анализа.
 
\end_layout

\begin_layout Standard
Одними из основных причин, делающих анализ для Ruby сложным и отпугивающим,
 являются: 
\end_layout

\begin_layout Itemize
динамическая типизация 
\end_layout

\begin_layout Itemize
не самая простая система типов (duck typing) 
\end_layout

\begin_layout Itemize
метапрограммирование 
\end_layout

\begin_layout Itemize
поддержка возможностей функционального программирования 
\end_layout

\begin_layout Standard
Такая область применения как интегрированные среды разработки накладывает
 специфические ограничения на статический анализатор: быстрое время отклика
 на вопросы в условиях постоянно изменяющейся программы, большой размер
 самой программы.
 В то же время не предъявляется требований к тому, чтобы анализировалась
 вся программа целиком.
\end_layout

\begin_layout Standard
Практически идеальным подходом к анализу в условиях описанных требований
 является управляемый запросами анализ с отсечениями (DDP), описанный в
 работе Спуна[].
 Данный подход оперирует с понятием запроса и позволяет производить лишь
 те вычисления, которые непосредственно необходимы для ответа на поставленный
 вопрос.
 Это позволяет эффективно работать с программи любых размеров.
 Возможность отсечений позволяет гарантировать то, что пользователь не будет
 ждать результатов анализа часами.
 
\end_layout

\begin_layout Standard
Полезным свойством такого подхода является то, что явно хранятся зависимости
 между запросами.
 Поэтому становится возможным эффективно пересчитывать результаты анализа
 при изменениях в программе, не выбрасывая все полученные ранее результаты.
 
\end_layout

\begin_layout Standard
Данная работа состоит из двух частей: теоретической и практической.
 Теоретическая часть предлагает модифицированный алгоритм DDP, позволяющий
 работать с инкрементальными запросами.
 Также описывается разработнный автором основанный на DDP статический анализ,
 позволяющий вычислять типы в языке Ruby.
 Приводятся оценки точности и времени работы.
 
\end_layout

\begin_layout Standard
Практическая часть представляет собой две реализации описанных алгоритмов.
 Первая реализация является существенно упрощенной (не поддерживается инкремента
льное обновление результатов, некоторые возможности языка).
 Не смотря на кажущиеся недостатки, она интегрирована в среду разработки
 DLTK Ruby [2], где успешно используется по всему миру.
 Вторая реализация соответсвует описанной в теоретической части, и подлежит
 интеграции в DLTK Ruby взамен первой.
 
\end_layout

\begin_layout Standard
Тестирование обеих реализаций показывает жизнеспособность предлагаемых алгоритмо
в и соотвествие ожиданиям, а также теоретическим оценкам.
 
\end_layout

\begin_layout Section
Задача
\end_layout

\begin_layout Subsection
Язык Ruby
\end_layout

\begin_layout Standard
Ruby — это динамический, рефлективный объектно-ориентированный язык общего
 применения.
 Ruby был создан в 1993 году в Японии.
 Действительную популярность язык приобрел в начале 2000х, после появления
 Ruby on Rails — системы программирования, позволяющей быстро разрабатывать
 веб-приложения.
 С того момента язык является крайне популярным, а Ruby on Rails, наверное,
 входит в тройку самых популярных решений для веб-приложений вместе с J2EE
 и PHP.
 Такая популярность и область применения открывают огромный спрос на “умные”
 развитые среды разработки, позволившие бы схожую c Java простоту редактирования
 кода.
 
\end_layout

\begin_layout Standard
Ruby поддерживает несколько парадигм программирования: функциональное, объектно-
ориентированное, императивное и рефлективное.
 Также он имеет динамическую типизацию и автоматическое управление памятью.
 В настоящий момент спецификации Ruby не сущесвует, и язык полностью определяетс
я существующей реализацией интерпретатора.
 
\end_layout

\begin_layout Standard
Посколько читатель может быть не знаком с деталями языка, представим некоторые
 ключевые его возможности.
 В Ruby все является объектом, и каждый объект является экземпляром какого-то
 конкретного класса.
 Например, литерал 42 является экземпляром класса Fixnum, true является
 экземпляром TrueClass, а nil это экземпляр NilClass.
 Как и в Java, корнем иерархии классов является Object.
 Классы являются экземплярами класса Class.
\end_layout

\begin_layout Standard
Есть несколько видов переменных, различаемых по префиксу: 
\end_layout

\begin_layout Itemize
локальные переменные не имеют префикса (x, y, z,...) 
\end_layout

\begin_layout Itemize
переменные экземпляра (поля) имеют префикс @ (@x, @y, @z, ...) 
\end_layout

\begin_layout Itemize
переменные класса (аналог статических переменных в Java) имеют префикс @@
 (@@x, @@y, ...) 
\end_layout

\begin_layout Itemize
глобальные переменные имеют префикс $ ($var)
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
Листинг 1
\begin_inset CommandInset label
LatexCommand label
name "Flo:Листинг-1"

\end_inset


\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Ruby,numbers=left,numberstyle={\small},stepnumber=1,tabsize=4"
inline false
status open

\begin_layout Plain Layout

a = 42 				# теперь a доступен
\end_layout

\begin_layout Plain Layout

b = a + 3 			# то же самое, что и b = a.+(3)
\end_layout

\begin_layout Plain Layout

c = d + 3 			# ошибка: d неопределен
\end_layout

\begin_layout Plain Layout

b = 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 			# b теперь экземпляр String
\end_layout

\begin_layout Plain Layout

b.length 			# вызов метода length без аргументов
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Container 		# по умолчанию наследник Object
\end_layout

\begin_layout Plain Layout

	def get()		# определение метода
\end_layout

\begin_layout Plain Layout

		@x		# чтения поля, метод возвращает это значение
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	def set(e)
\end_layout

\begin_layout Plain Layout

		@@last = @x	# запись в переменную класса
\end_layout

\begin_layout Plain Layout

		@x = e		# запись в поле
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	def Container.last() 	# метод класса
\end_layout

\begin_layout Plain Layout

		$gl = @@last
\end_layout

\begin_layout Plain Layout

		@@last
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

f = Container.new	# создание экземпляра
\end_layout

\begin_layout Plain Layout

f.set(3)	# можно было также написать f.set 3
\end_layout

\begin_layout Plain Layout

g = f.get	# g = 3
\end_layout

\begin_layout Plain Layout

f.set(4)
\end_layout

\begin_layout Plain Layout

h = Container.new.get	# возвращает nil
\end_layout

\begin_layout Plain Layout

l = Container.last	# возвращает 3
\end_layout

\begin_layout Plain Layout

$gl		# возвращает 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

i = [1, 2, 3]	# литерал массива
\end_layout

\begin_layout Plain Layout

j = i.collect { |x| x + 1 } 	# теперь j равен [2, 3, 4]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module MyEnumerable	# определение модуля
\end_layout

\begin_layout Plain Layout

	def leq(x)
\end_layout

\begin_layout Plain Layout

		(self.twc x) <= 0	# заметим, что метода 
\begin_inset Quotes eld
\end_inset

twc
\begin_inset Quotes erd
\end_inset

 здесь нет
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Container
\end_layout

\begin_layout Plain Layout

	include MyEnumerable	# 
\begin_inset Quotes eld
\end_inset

примешиваем
\begin_inset Quotes erd
\end_inset

 модуль
\end_layout

\begin_layout Plain Layout

	def twc(other)		# объявляем недостающий метод
\end_layout

\begin_layout Plain Layout

		@x.twc other.get
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f.twc f	# возвращает 0
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Листинг 1 демонстрирует образец кода на Ruby и иллюстрирует некоторые возможност
и языка.
 Локальные переменные не видны вне окружающей их определение области (scope).
 Локальная переменная начинает существовать в момент ее первого определения.
 Обращаться до определения к переменным нельзя.
 Поскольку Ruby динамически типизирован, в ходе работы программы переменная
 может принимать значения различных типов.
 
\end_layout

\begin_layout Standard
Строки 7-19 определяют новый класс Container с методами get и set, методом
 класса last , переменной экземпляра @x и переменной класса @@last.
 Возвращаемым значением метода является результат последней вычисленной
 команды (строка 9).
 Также возможны явные команды return.
 Экземпляры классов создаются с помощью метода new.
\end_layout

\begin_layout Standard
Синтаксис вызова методов стандартный (строка 21), хотя круглые скобки можно
 опускать (строки 20 и 22).
 Имена методов не обязаны быть буквено-числовыми: возможен метод с именем,
 например “+”.
 В частности в строке 2 на самом деле вызывается метод (a.+(3)).
\end_layout

\begin_layout Standard
В отличие от локальных переменных, переменные экземпляров, классов и глобальные
 переменные инициализиются значением nil.
 Переменные класса являются общими для всех экземпляров класса.
 Говоря о правилах видимости, переменные классов и экземпляров доступны
 только внутри их класса.
 Глобальные переменные видны всюду.
 Также, всегда доступна переменная self, устанавливаемая в зависимости от
 контекста.
\end_layout

\begin_layout Standard
В языке есть константы.
 Константой является любая переменная, имя которой начинается с заглавной
 буквы.
 В частности, имена классов являются константами.
\end_layout

\begin_layout Standard
Как и большинство динамических языков, Ruby имеет специальный синтаксис
 для литералов массивов (строка 28) и хэш-таблиц.
\end_layout

\begin_layout Standard
Также Ruby поддерживает функции высшего порядка, называемые Ruby-блоками
 (или просто блоками).
 Строка 29 показывает вызов метода collect, который создает новый массив
 применением переданного ему блока к каждому элементу исходного массива.
 Между вертикальными скобками указываются агрументы блока.
 Надо заметить, что в отличие от методов, блоки имеют доступ к локальным
 переменным окружающей их области.
 Любой метод в Ruby может принимать один блок в качестве последнего аргумента
 и вызывать его с помощью команды yield(v1,...vn).
 Блоки можно передавать и в качестве обычных аргументов, однако это не тривиальн
о и редко применяется.
 
\end_layout

\begin_layout Standard
Ruby поддерживает единственное наследование.
 Синтаксис class Foo < Bar означает, что класс Foo наследуется от класса
 Bar.
 Если суперкласс не указан, то он предполагается равным Object.
 
\end_layout

\begin_layout Standard
Аналогом множественного наследования в Ruby являются модули (modules, mixins).
 Например, строки 31-35 определяют модуль My_enumerable, который определяет
 метод leq в терминах другого метода twc.
 В строках 37-42 мы “примешиваем” модуль My_enumerable с помощью команды
 include и затем определяем необходимый метод twc.
 Начиная со строки 44 мы можем вызывать Container.leq.
 Заметим, что в строке 37 мы дополняем определение класса Container и примешивае
м модуль и добавляем метод.
 Это один из способов программ изменять классы.
 
\end_layout

\begin_layout Standard
Другими способом изменять класс являются методы alias и define_method.
 Вызывая alias у класса, мы можем создать копию какого-либо метода под другим
 именем.
 Вызов define_method принимает в качестве аргументов имя и блок, из которых
 под заданным именем создается метод.
 
\end_layout

\begin_layout Standard
Возможно создавать методы, специфичные для конкретного экземпляра (eigen
 methods или singleton methods).
 Синтаксис def obj.meth() ...
 end объявляет метод meth, который будет доступен только у экземпляра obj.
 Аналогичным по действию является синтаксис class << obj, позволяющий объявить
 несколько методов за раз и создающий область с переменной self равной obj.
 Возможность создавать методы специфичные для конкретных экземпляров означает,
 что тип в Ruby определяется не столько классом, сколько набором доступных
 у экземпляра методов.
 
\end_layout

\begin_layout Standard
Наконец, язык поддерживает возможность исполнения строк как кода на Ruby
 (eval, instance_eval, etc.).
\end_layout

\begin_layout Subsection
Специфика интегрированных сред разработки
\end_layout

\begin_layout Standard
Такая область применения как интегрированные среды разработки имеет свою
 специфику, отличную от специфики применения статических анализаторов в
 трансляторах и верификаторах.
 Рассматривая самые востребованные действия пользователя, которые могут
 потребовать анализа программы, можно выделить следующие:
\end_layout

\begin_layout Enumerate
Подсказка при вводе метода (code completion).
 Реализация данной функции требует знать список имен методов, которые можно
 вызвать в указанной точке программы.
 А значит, это требует вычисления типа объекта, у которого вызывается метод.
 
\end_layout

\begin_layout Enumerate
Переход к определению (jump to declaration).
 Реализация перехода к определению требует зная имя метода, перейти к его
 определению.
 Для этого опять же нужно знать тип объекта, у которого вызывается метод.
 
\end_layout

\begin_layout Standard
Первой особенностью, которую можно заметить из данных кратких описаний,
 является формат обращения к анализу: в обоих случая это вопрос об одной
 единственной конкретной переменной (или выражении, что не важно).
 
\end_layout

\begin_layout Standard
Второй особенностью, и в частности требованием, является необходимость в
 малом времени на ответ на такие вопросы.
 Пользователь может ждать секунду-две, но не больше.
 При этом он не сильно огорчится, если результат окажется не полным или
 даже не корректным.
\end_layout

\begin_layout Standard
Треьей особенностью является то, что редактируя код, пользователь изменяет
 программу.
 А значит если статический анализатор сохраняет какие-либо результаты вычислений
 для оптимизации (а это логично делать), то после изменения программы, он
 должен эффективно их пересчитать.
 Можно привести простой практический пример: программа состоит из большой
 библиотеки и небольшого клиентского кода, ее использующего.
 Если пользователь работает над клиентским кодом, не изменяя код библиотеки,
 не эффективно переанализировать ее при каждом запросе к анализу.
 Здесь нужно заметить, что длительный анализ в момент запуска среды разработки
 не возбраняется.
 Тем не менее при изменении кода, задержки на анализ должны быть пропорциональны
 масштабности изменений.
 
\end_layout

\begin_layout Standard
Наконец, нужно сказать про реализационные особенности.
 Так как среда разработки часто использует промежуточное представление и
 индексы, аналогичные тем, что могут понадобиться анализу, рациональным
 является переиспользование этих структур между друг другом.
 А это означает, что анализ также должен быть реализован на языке, на котором
 возможна среда разработки.
 Рассматривая существующие среды, которые позволяют интеграцию в них анализа
 для Ruby, таким языком является Java.
 
\end_layout

\begin_layout Standard
Еще одним аспектом, ограничивающим выбор языка программирования для реализации,
 является скорость.
 К сожалению удобные для написания статического анализа языки, такие как
 Prolog, сам Ruby, Python, OCaml исполняются несравнимо более медленно чем
 Java.
\end_layout

\begin_layout Subsection
Существующие решения
\end_layout

\begin_layout Subsubsection
Специфичные для Ruby 
\end_layout

\begin_layout Paragraph
Static Type Inference for Ruby 
\end_layout

\begin_layout Standard
Авторами предлагается система под названием DRuby для поиска ошибок в программах
 на языке Ruby.
 Работа включает алгоритм для вычисления типов.
 Их алгоритм основывается на итеративном решении построенной системы ограничений
 и предлагается его реализация на OCaml.
 Авторы утверждают, что их алгоритм выдает точные ответы во всех возможных
 случаях.
 Однако время работы на тестовой программе в 800 строк составляет 36.1 секунды,
 что является слишком медленным, чтобы использовать их алгоритм в интерактивных
 средствах.
 Одним из результатов их работы являются типовые аннотации для стандартной
 библиотеки Ruby.
 Представленная здесь работа переиспользует этот результат.
 
\end_layout

\begin_layout Paragraph
RadRails, RubyMine 
\end_layout

\begin_layout Standard
RadRails и RubyMine это популярные среды разработки для Ruby с поддержкой
 помощи пользователю (code completion).
 Документальных описаний статического анализа в них не известно.
 Однако экспериментальная проверка показала, что авторами скорее всего используе
тся тривиальный внутрипроцедурный анализ.
\end_layout

\begin_layout Subsubsection
Другие динамические языки 
\end_layout

\begin_layout Paragraph
DDP
\end_layout

\begin_layout Standard
Автором предлагается статический анализатор для языка Smalltalk основанный
 на управляемом запросами анализе с отсечениями.
 В ней показывается применимость данного подхода к задачам статического
 анализа, а также выигрышность по сравнению с классическими (итеративными)
 подходами.
 Именно данная работа послужила источником идей для написания представленной,
 т.к.
 Smalltalk является во многом похожим на Ruby.
\end_layout

\begin_layout Subsection
Формальная постановка задачи
\end_layout

\begin_layout Standard
Задача состоит в разработке программной системы (статического анализатора),
 принимающего на вход обозначенные ниже данные и выдающие обозначенный ниже
 результат.
\end_layout

\begin_layout Standard

\series bold
Вход.
 
\end_layout

\begin_layout Standard
На вход анализатора поступает программа на Ruby: набор .rb файлов R, а также
 выбранный среди них файл m 
\backslash
in R, являющийся файлом, который непосредственно передается интерперетатору
 Ruby в качестве входного.
 Этот файл может включать остальные с помощью команды require.
 
\end_layout

\begin_layout Standard
Также анализатору указывается файл из входного набора и позиция в нем.
 На указанной позиции в этом файле должен находиться литерал, ссылающийся
 на какую-либо переменную.
 
\end_layout

\begin_layout Standard

\series bold
Выход.
 
\end_layout

\begin_layout Standard
На выход алгоритм должен выдать описание типа обозначенной на входе переменной.
 Описание типа должно следовать следующей структуре:
\end_layout

\begin_layout Standard
ОписаниеТипа := Тип (или Тип)* 
\end_layout

\begin_layout Standard
Тип := (Источник, Методы) 
\end_layout

\begin_layout Standard
Источник := <конкретное имя класса> 
\end_layout

\begin_layout Standard
Источник := <вызов метода new> 
\end_layout

\begin_layout Standard
Источник := <произвольный вызов с неизвестным возвращаемым типом> 
\end_layout

\begin_layout Standard
Источник := <неопределенная переменная> 
\end_layout

\begin_layout Standard
Методы := Метод* 
\end_layout

\begin_layout Standard
Метод := <описание сигнатуры метода: имя и агрументы> 
\end_layout

\begin_layout Standard
Описание типа должно соответствовать типам, которые может принимать указанная
 переменная в процессе работы программы.
 
\end_layout

\begin_layout Section
Решение
\end_layout

\begin_layout Subsection
Управляемый запросами анализ
\end_layout

\begin_layout Standard
Большинство из описанных ниже идей были заимствованы из работы Спуна[],
 которые им в свою очередь были заимствованы из экспертных систем.
 Таким образом общая идея управляемых запросами алгоритмов не нова.
 Данная работа расширяет существующие решение поддержкой кеширования результатов
 между вопросами и эффективным обновлением закешированных данных при изменении
 входных данных.
\end_layout

\begin_layout Subsubsection
Идея
\end_layout

\begin_layout Standard
Рассмотрим несколько наблюдений над существующими работами и над природой
 самой задачи.
 Данные наблюдения позволят лучше понять как решать поставленную задачу.
 
\end_layout

\begin_layout Standard
Во-первых, все современные контекстно-зависимые алгоритмы не масштабируемы.
 0-CFA, CPA и k-CFA [] не способны справиться с программами в несколько
 десятков тысяч строк.
 
\end_layout

\begin_layout Standard
Во-вторых, в любых программах, даже самых больших, большинство типов всегда
 вычисляется очень просто.
 Достаточно посмотреть на расположенные рядом присваивания, чтобы найти
 подходящий литерал.
 Любой человек таким образом взглянув на программу способен дать результат,
 попой более точный чем любой из существующих анализаторов.
 
\end_layout

\begin_layout Standard
В-третьих, инкрементальный анализ традиционно считается крайне сложной задачей.
 В то же время, идея удаления ставших некорректными результатов, затем тех,
 которые зависят от них и т.д.
 выглядит тривиальной, если известны зависимости между результатами и результаты
 достаточно мелки.
 
\end_layout

\begin_layout Standard
Наконец, рассмотрим такой пример ситуации.
 В любой достаточно большой программе всегда найдется метод, который вызывается
 из тысячи мест.
 Практически любой из существующих анализаторов потратил бы время на рассмотрени
е каждого из них.
 В то же время, для точного ответа на поставленный ему вопрос скорее всего
 достаточно рассмотрения лишь десятка из них.
 
\end_layout

\begin_layout Standard
Главной идеей является то, что статический анализатор мог бы, имея ограниченные
 ресурсы, потратить их на поиск ответа на заданный вопрос.
 Если ресурсов оказалось недостаточно, то он должен выдать тривиальный корректны
й ответ.
 При этом для разных типов вопросов он применял бы различные стратегии вычислени
я.
 Тогда на простые вопросы он мог бы отвечать быстро и хорошо, а на сложные
 хуже.
 
\end_layout

\begin_layout Standard
Управляемый запросами алгоритм следует описанной идее.
 На каждый поставленный ему вопрос выбирается своя стратегия вычисления.
 При этом в поисках ответа на вопрос он может задавать новые вопросы.
 
\end_layout

\begin_layout Standard
Естественным расширением этой идее является то, что алгоритм мог бы не искать
 ответа на некоторые возникшие вопросы.
 В таком случае, если изначальный вопрос приводит к очень сложным вопросам,
 ответ на которые результат не улучшит, он мог бы не вычислять только их,
 Это позволило бы успешно ответить на изначальный вопрос в условиях ограниченных
 ресурсов.
 Данное уточнение позволяет называть алгоритм управляемым запросами с отвечениям
и.
 
\end_layout

\begin_layout Standard
Естественным расширением этой идее является то, что алгоритм мог бы не искать
 ответа на некоторые возникшие вопросы.
 В таком случае, если изначальный вопрос приводит к очень сложным вопросам,
 ответ на которые результат не улучшит, он мог бы не вычислять только их,
 Это позволило бы успешно ответить на изначальный вопрос в условиях ограниченных
 ресурсов.
 Данное уточнение позволяет называть алгоритм управляемым запросами с отвечениям
и.
 
\end_layout

\begin_layout Standard
Важно заметить, что отсечения можно делать не с любыми вопросами.
 Поэтому вопросы должны быть правильно сформулированы.
 Например, вопрос “какой тип имеет x?” можно легко отсечь, потому что для
 него существует тривиальный корректный ответ: “Object”.
 Вопрос вида “проанализируй строку n и обнови таблицу b” отсекать невозможно,
 т.к.
 это вопрос в общем-то не является.
 Вообще, рассматривая данные примеры, становится ясным, что к вопросам предъявля
ются следующие требования: 
\end_layout

\begin_layout Itemize
существование тривиального корректного ответа
\end_layout

\begin_layout Itemize
отсутсвие побочных эффектов от их рассмотрения (то есть каждый вопрос рассматрив
ается изолированно)
\end_layout

\begin_layout Standard
Наконец, представим ситуацию, в которой алгоритму постоянно задают вопросы.
 Логично, что многие вопросы возникающие в процессе анализа будут повторяться.
 Поэтому естественным является записывать ответы на них, чтобы при повторых
 подобных вопросах не искать на них ответ.
 
\end_layout

\begin_layout Standard
Данная оптимизация, тем не менее, затрудняется если входные данные алгоритма
 меняются время от времени.
 Это означает, что старые ответы уже не корректны.
 Однако, бывает, решив какую-то задачу на бумаге, а потом получив аналогичную,
 вы переиспользуете большинство своих записей.
 Вы последовательно зачеркиваете устаревшие записи и записываете новые вместо
 них, затем те, на что те повлияили и т.д.
 Естественным решением проблемы, которое использует человек, является запоминани
е того, как вопросы зависят друг от друга и от входных данных.
 Подобную стратегию можно применять и при статическом анализе.
 
\end_layout

\begin_layout Subsubsection
Алгоритм
\end_layout

\begin_layout Standard
Предлагаемы алгоритм использует подход описанный выше.
 Он управляется запросами, позволяет делать делать отсечения и эффективно
 кеширует ответы между вопросами.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
Листинг 2
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

ПРОЦЕДУРА Вычислить(корневаяЦель)
\end_layout

\begin_layout Plain Layout

	ЕСЛИ completed contains rootgoal ТО
\end_layout

\begin_layout Plain Layout

		ВЕРНУТЬ GoalAnswer(rootgoal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	worklist := { rootgoal }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while worklist != {} do
\end_layout

\begin_layout Plain Layout

		ЕСЛИ pruner wants to run
\end_layout

\begin_layout Plain Layout

		ТО Prune()
\end_layout

\begin_layout Plain Layout

		else UpdateOneGoal()
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	ВЕРНУТЬ GoalAnswer(rootgoal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure UpdateOneGoal()
\end_layout

\begin_layout Plain Layout

	Remove g from worklist
\end_layout

\begin_layout Plain Layout

	changed := Update(g)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ЕСЛИ changed ТО
\end_layout

\begin_layout Plain Layout

		deps := GoalsNeeding(g)
\end_layout

\begin_layout Plain Layout

		worklist := worklist + deps
\end_layout

\begin_layout Plain Layout

		completed := completed - deps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure Prune()
\end_layout

\begin_layout Plain Layout

	for g in ChoosePrunings() do
\end_layout

\begin_layout Plain Layout

		prune g
\end_layout

\begin_layout Plain Layout

	worklist := Relevant(rootgoal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procudure InputAffected(goal)
\end_layout

\begin_layout Plain Layout

	changed := Update(g)
\end_layout

\begin_layout Plain Layout

	ЕСЛИ changed ТО
\end_layout

\begin_layout Plain Layout

		Wipe(goal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure Wipe(goal)
\end_layout

\begin_layout Plain Layout

	complete := completed - goal
\end_layout

\begin_layout Plain Layout

	deps := GoalsNeeding(goal)
\end_layout

\begin_layout Plain Layout

	for g in deps do 
\end_layout

\begin_layout Plain Layout

		Wipe(g)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Псевдокод алгоритма преставлен в Листинге 2.
 На вход алгоритм принимает goal — исходный запрос.
 Выходом алгоритма является ответ на поставленный запрос.
 
\end_layout

\begin_layout Standard
Главной частью алгоритма является множество worklist содержащее набор запросов,
 ответы на которые нужно обновить.
 Алгоритм последовательно выбирает из worklist запросы и обновляет их ответы.
 Если после обновления ответа как какой-то запрос, ответ действительно изменился
, тогда все запросы зависящие от данного помещаются в worklist, так как
 теперь их ответ тоже мог измениться.
 Алгоритм останавливается, когда worklist окажется пустым, а значит ответы
 на все запросы будут согласованы с ответами на подзапросы.
 
\end_layout

\begin_layout Standard
Функция UpdateOneGoal обновляет ответ на переданный ей запрос та, чтобы
 он учитывал ответы на подзапросы.
 Например, для запроса “тип x?” ответ может уточниться с “Fixnum” до “Fixnum
 or Float”.
 Функция Update выполняет данное уточнение и возвращает булево значение,
 означающее изменился ответ по сравнению с предыдущим или нет.
\end_layout

\begin_layout Standard
Точное поведение Update зависит от конкретных типов вычислений, производимых
 с помощью данного алгоритма, и применительно к анализу Ruby рассматривается
 далее.
 Заметим, что если обновляемому запросу потребовались новые подзапросы,
 ранее не существовавшие, то тогда они создаются, инициализируются минимальным
 ответом и добавляются в worklist.
 Если обновление ответа привело к тому, что ответ действительно изменился,
 то UpdateOneGoal помещает в worklist все запросы, запрашивающие его как
 подзапрос.
\end_layout

\begin_layout Standard
Время от времени алгоритм вызывает Prune и отсекает некоторые подзапросы.
 ChoosePrunings выбирает какие запросы должны быть отсечены.
 ChoosePrunings это эвристика, и существует множество возможных стратегий
 по ее реализации.
 Всем запросам, которые отсекаются, назначается тривиальный ответ.
 После этого worklist очищается от отсеченных запросов, так чтобы он содержал
 только исходный запрос и все непосредственные и косвенные его подзапросы.
\end_layout

\begin_layout Standard
Для того чтобы GoalsNeeding не нарушала эффективности алгоритма, нужно чтобы
 после отсечений она не возвращала отсеченных запросов.
 Иначе это будет фактически отменять отсечения.
 Логично хранить дополнительный набор completed.
 Он должен хранить все запросы, которые обработаны и ответы на которые уже
 согласованы с подзапросами.
 Непосредственно после обновления запроса он должен помещаться в compeleted.
 И когда запрос помещается в worklist, он должен исключаться из completed.
 Таким образом во время работы алгоритма запросы перемещаются из completed
 в worklist и обратно, всегда находясь в одном из них.
 Отсеченные запросы удаляются из обоих наборов.
 GoalsNeeding же может возвращать только запросы, находящиеся каком-то из
 этих множеств.
\end_layout

\begin_layout Standard
Функция InputAffected вызывается между вызовами Evaluate, то есть предполагается
, что все обработанные ранее запросы находятся в completed.
 InputAffected перевычисляет потенциально изменившийся запрос, при условии
 что у него было подзапросов (а значит он непосредственно зависил от входных
 данных и только).
 В случае, если его ответ действительно изменился, запрос, а также все прямо
 и косвенно зависящие от него удаляются из completed.
 Теперь при следующем обращении к Evaluate их потребуется вычислить заново.
\end_layout

\begin_layout Subsubsection
Пример работы
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsubsection
Свойства
\end_layout

\begin_layout Standard
Приведенный алгоритм обладает несколькими полезными свойствами.
 По-первым время его работы зависит только от количества обрабатываемых
 запросов и того, сколько раз каждый из них обрабатывается.
 По крайней мере прямой зависимости от того, насколько большая программа
 анализуется не ожидается.
 А значит алгоритм должен работать одинаково быстро вне зависимости от размера
 входной программы, если ограничить количество запросов (это позволяют сделать
 отсечения).
 
\end_layout

\begin_layout Standard
Затем, алгоритм в простых случаях находит ответ моментально.
 Так, вопросы приводящие через один-два шага к литералам, гарантированно
 будут найдены.
 
\end_layout

\begin_layout Standard
Наконец, алгоритм может быть настроеным под конкретную ситуацию.
 Выбирая стратегии отсечения можно контролировать соотношение скорости/качества.
 Также, обратим внимание на то, что не было указано, по какому принципу
 выбирается следующий запрос из worklist.
 Это также влияет на свойства алгоритма.
\end_layout

\begin_layout Standard
Если worklist работает по принципу очереди, то сначала будут рассматриваться
 более новые подзапросы.
 А значит алгоритм будет больше уходить “в глубину”, обновляя ответы на
 вопросы близкие к корневому в последнюю очередь.
 Если же worklist организовать по принципу стека, то появление конкретного
 ответа на какой-то подвопрос будет в первую очередь “просачиваться” на
 верх и уточнять корневой запрос до рассмотрения остальных подзапросов.
 Однакой ценой за такие скорые ответы является то, что корневой вопрос будет
 пересчитываться каждый раз, когда обновится какой-то из подзапросов, что
 может привести к общему замедлению работы.
\end_layout

\begin_layout Standard
Итак, стратегию выбора следующего запроса можно выбирать в зависимости от
 наличия ресурсов и конкретной задачи.
 При этом на результат данный выбор не влияет.
\end_layout

\begin_layout Standard

\series bold
Утв.
 (корректность):
\series default
 Для любой стратегии выбора остановка алгоритма означает, что все ответы
 на все запросы согласованы с ответами на подзапросы.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\blacktriangleleft$
\end_inset

очевидно 
\begin_inset Formula $\blacktriangleright$
\end_inset


\end_layout

\begin_layout Standard
Теперь давайте вернемся к словам про то, от чего зависит время работы алгоритма.
 Как было замечено, запросы могут обрабатываться несколько раз — фактически,
 каждый раз, когда изменятся ответ какого-то из их подзапроса.
 Возникает логичный вопрос о том, как часто один запрос может обновляться,
 и вообще останавливается ли алгоритм.
\end_layout

\begin_layout Standard
Во-первых, как уже было замечено, выбор стратегии может влиять на то как
 часто запросы перевычисляются.
 Это является отдельным полем для исследования, и наверняка можно выбрать
 как стратегию с минимальным количеством пересчетов, так и с максимальным.
 Однако нам важен лишь тот факт, но данный выбор не влияет на результат.
\end_layout

\begin_layout Standard
Во-вторых, давайте представим запросы и завимости между ними как орграф.
 Граф может быть двух видов: циклический и ациклический.
 Можно доказать следующее утверждение:
\end_layout

\begin_layout Standard

\series bold
Утв.
 (критерий остановки №1):
\series default
 Если запросы образуют ациклический граф, то для любых стратегий выбора
 и отсечения алгоритм останавливается.
 
\end_layout

\begin_layout Standard

\series bold
\begin_inset Formula $\blacktriangleleft$
\end_inset


\series default
 Индукция по размеру (к-ву вершин) подграфа подзапроса.
 
\begin_inset Formula $\blacktriangleright$
\end_inset


\end_layout

\begin_layout Standard
Если граф циклический, алгоритм может не останавлиться.
 Но так как предусмотрены отсечения, то выбрав подходящую стратегию отсеения
 можно алгоритм остановить.
 
\end_layout

\begin_layout Standard
Все же попробуем придумать условия, при которых можно гарантировать остановку.
 Пусть все возможные результаты какого-либо запроса упорядочены, т.е.
 для любых двух ответов 
\begin_inset Formula $a_{1}$
\end_inset

 и 
\begin_inset Formula $a_{2}$
\end_inset

 можно было бы сказать 
\begin_inset Formula $a_{1}<a_{2}$
\end_inset

, 
\begin_inset Formula $a_{1}=a_{2}$
\end_inset

 или 
\begin_inset Formula $a_{1}>a_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
Опр.: 
\series default
Запрос будем называть монотонным, если при каждом последующем его обновлении
 предыдущий результат всегда больше (всегда меньше) предудущего.
 
\end_layout

\begin_layout Standard
Тогда можно сформулировать следующее утвреждение:
\end_layout

\begin_layout Standard

\series bold
Утв.
 (критерий остановки №2):
\series default
 Если все запросы монотонны и множество результатов каждого конечно, то
 алгоритм всегда останавливается.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\blacktriangleleft$
\end_inset

 Для любого запроса рано или поздно наступит момент, когда он больше не
 будет изменять свой ответ, оставаясь согласованным со своими подзапросами.
 А значит также рано или поздно все запросы окажутся согласнованными и алгоритм
 остановится.
 
\begin_inset Formula $\blacktriangleright$
\end_inset


\end_layout

\begin_layout Subsection
Первоначальные преобразования
\end_layout

\begin_layout Standard
В одной из предыдущих частей мы описали поставленную задачу следующих образом:
 
\end_layout

\begin_layout Standard

\emph on
Вход.
 
\end_layout

\begin_layout Standard

\emph on
На вход анализатора поступает программа на Ruby: набор .rb файлов R, ...
 
\end_layout

\begin_layout Standard
Иными словами, на вход разрабатываемого статического анализатора поступает
 текст программы.
 Очевидно, что производить анализ оперируя с текстом невероятно сложно и
 глупо.
 
\end_layout

\begin_layout Standard
Поэтому до начала непосредственно анализа программа проделывает следующий
 путь:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ir.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
Первым преобразованием является лексический и синтаксический анализ.
 Выходом этого преобразования является абстрактное абстрактное дерево синтаксиса
 (АДС или AST).
 
\end_layout

\begin_layout Standard
Теоретически, анализ программы уже можно проводить на данном представлении.
 Однако, это не является удобным ввиду следующих причин: 
\end_layout

\begin_layout Itemize
АСД содержит слишком много конструкций, многие из которых равнозначны при
 вычислении типов 
\end_layout

\begin_layout Itemize
АСД не отражает аспектов касающихся потоков данных и потока исполнения программы
 
\end_layout

\begin_layout Standard
Поэтому, АСД преобразуется дальше в структуры данных, удобные для нашего
 анализа, которые мы и называем внутренним представлением.
 
\end_layout

\begin_layout Subsection
Внутренее представление
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsection
Индексы
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsection
Запросы
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsubsection
Запросы о значениях
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsubsection
Запросы об использованиях
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsubsection
Запросы о точках вызова
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Subsubsection
Запросы о вызываемом коде
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Section
Результаты и эксперименты
\end_layout

\begin_layout Standard
// TODO
\end_layout

\begin_layout Section
Заключение
\end_layout

\begin_layout Standard
В данной работе была описана система для статического анализа программ на
 языке Ruby подходящая для использования в интегрированных средах разработки,
 тем самым удовлетворяющая поставленной задаче.
\end_layout

\begin_layout Standard
Была произведена следующая работа:
\end_layout

\begin_layout Itemize
разработан, описан и реализован модифицированный алгоритм DDP с поддержкой
 кеширования между запросами и икрементальным обновленим результатов
\end_layout

\begin_layout Itemize
исследован и описан язык Ruby c точки зрения проблем статического анализа
\end_layout

\begin_layout Itemize
разработан, описан и реализован основанный на модифицированном DDP статический
 анализ для языка Ruby, позволяющий вычислять типы
\end_layout

\begin_layout Itemize
в рамках проекта DLTK Eclipse Foundation был реализован упрощенный статический
 анализатор для языка Ruby, а также алгоритм DDP без поддержки инкрементальности
\end_layout

\begin_layout Standard
Вместе с работой Спуна, данная работа показывает актуальность применения
 алгоритмов основанных на запросах в статическом анализе.
 Данный подход позволяет успешно решать проблему масштабирования, остро
 стоящую для многих алгоритмов анализа, при этом не значительно теряя в
 точности.
 Важно заметить, что такой подход может быть применен не только к анализу
 программ на языке Ruby, но и к анализу любых программ вообще.
 Более того, такой подход может быть применен для решения задач не только
 анализа программ.
 Крайне интересны возможные применения управляемого запросами анализ к задачам
 биоинформатики, социологии, экономики связанных с системами взаимосвязанных
 элементов.
 
\end_layout

\begin_layout Standard
Наконец, еще одним существенным преимуществом такого подхода является предраспол
оженность к распараллеливанию.
 Если вычисляемые наборы запросов независимы, их можно эффективно вычислять
 на различных ядрах процессора.
 Решение задачи распараллеливания является одним из следующих шагов данной
 работы.
\end_layout

\begin_layout Standard
Тестирование реализации анализа для языка Ruby показало приемлимый уровень
 точности анализа.
 Однако были выявленны не учтенные изначально особенности языка, требущие
 более подробного рассмотрения: коллекции, исключения.
 Также было обнаружено, что точность описания библиотек и нативных функций
 оказывает крайне существенное влияние на точность анализа.
 
\end_layout

\begin_layout Standard
Реализация в рамках проектах Eclipse DLTK является достаточно популярной
 и достаточно порадовавшей многих разрабочиков на Ruby [].
 Также эта реализация используется в среде разработки для Ruby On Rails
 3rd Rail от CodeGear (бывшая Borland).
\end_layout

\begin_layout Standard
Наконец, данная работа является примером возможности создания практически
 полезных статических анализаторов для динамически типизированных языков.
 В частности, она может быть полезна при создании анализаторов для других
 динамических языков, таких как Python или PHP.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
makeatletter 
\end_layout

\begin_layout Plain Layout


\backslash
bibliographystyle{unsrt} 
\end_layout

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
@biblabel}[1]{#1.}  
\end_layout

\begin_layout Plain Layout


\backslash
makeatother
\end_layout

\end_inset


\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "/Users/fourdman/Desktop/bibliography"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
